// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_SM_matching.hpp"
#include "wrappers.hpp"
#include "two_scale_matching.hpp"
#include "SM_mass_eigenstates.hpp"
#include "@ModelName@_mass_eigenstates.hpp"
#include <cmath>

namespace flexiblesusy {

#define MODELPARAMETER(p) model.get_##p()
#define SMPARAMETER(p) SM_.get_##p()
#define INPUTPARAMETER(p) model.get_input().p

/**
 * matches Standardmodel from @ModelName@-Model at tree-level
 */
void @ModelName@_SM_matching::matchingTL(SM_mass_eigenstates& SM_, const @ModelName@_mass_eigenstates& model)
{
  SM_.set_scale(model.get_scale());
  SM_.set_g1(model.get_@hyperchargeCoupling@()*@hyperchargeCouplingGutNormalization@/Sqrt(.6));
  SM_.set_g2(model.get_@leftCoupling@()*@leftCouplingGutNormalization@);
  SM_.set_g3(model.get_@strongCoupling@());
  SM_.set_v(2.*model.get_M@VectorW@()/SM_.get_g2());
  SM_.set_Ye(Sqrt(2.)/SM_.get_v()*model.get_M@Electron@().matrix().asDiagonal());
  SM_.set_Yu(-Sqrt(2.)/SM_.get_v()*model.get_M@TopQuark@().matrix().asDiagonal());
  SM_.set_Yd(Sqrt(2.)/SM_.get_v()*model.get_M@BottomQuark@().matrix().asDiagonal());
  SM_.set_Lambdax(Sqr(model.get_M@HiggsBoson@()@LightestHiggsExtension@)/Sqr(SM_.get_v()));
  SM_.set_mu2( 1.5*SM_.get_Lambdax()*Sqr(SM_.get_v()) - Sqr(model.get_M@HiggsBoson@()@LightestHiggsExtension@));
  SM_.solve_ewsb_tree_level();
  SM_.calculate_DRbar_masses();
}


/**
 * matches Standardmodel from @ModelName@-Model at one-loop-level
 */
void @ModelName@_SM_matching::matching(SM_mass_eigenstates& SM_, const @ModelName@_mass_eigenstates& model)
{
  const double currentScale = model.get_scale();
  double MWMSbar2, MZMSbar2, MHMSbar2;
  Eigen::Array<double, 3, 1> MuMSbar, MdMSbar, MeMSbar;

  //match with tree-level as initial guess
  matchingTL(SM_, model);
  double g1drbar = SM_.get_g1();
  double g2drbar = SM_.get_g2();
@calcAlphaEM@
  double alpha_s  = Sqr(SM_.get_g3())/(4.*Pi);
@gauge1Linit@
@alphaEM1Lmatching@
@alphaS1Lmatching@

   //calculate 1-loop corrected masses
   SM_.solve_ewsb_one_loop();
   MHMSbar2 = Mhh2matching1L(model);
   MWMSbar2 = MVWp2matching1L(model);
   MZMSbar2 = MVZ2matching1L(model);

   //assuming no flavor mixing: yukawa matrices and self energies are diagonal
   for(unsigned i = 0; i < 3; i++)
   {
      MeMSbar(i) = Sqrt(MFe2matching1L(model, i));
      MuMSbar(i) = Sqrt(MFu2matching1L(model, i));
      MdMSbar(i) = Sqrt(MFd2matching1L(model, i));
   }

   //copy SM-class for TL - template
   const SM_mass_eigenstates SM_TL = SM_;

   //calculate 1L-parameters from 1L-masses
   SM_.set_g1(Sqrt(4.*Pi*alpha_em *(1. - delta_alpha_em + MZMSbar2/Sqr(SM_TL.get_MVZ()) - MWMSbar2/Sqr(SM_TL.get_MVWp()) )*Sqr(SM_TL.get_MVZ()/SM_TL.get_MVWp()))/Sqrt(.6));
   SM_.set_g2(Sqrt(4.*Pi*alpha_em/(1. - Sqr(SM_TL.get_MVWp()/SM_TL.get_MVZ()))*
               (1. - delta_alpha_em + Sqr(SM_TL.get_MVWp()/SM_TL.get_MVZ())*(-MZMSbar2/Sqr(SM_TL.get_MVZ()) + MWMSbar2/Sqr(SM_TL.get_MVWp()))/(1. - Sqr(SM_TL.get_MVWp()/SM_TL.get_MVZ())))));
   SM_.set_g3(Sqrt(4.*Pi*alpha_s *(1. - delta_alpha_s)));
   SM_.set_v(2.*SM_TL.get_MVWp()/SM_TL.get_g2()*Sqrt(1. + MWMSbar2/Sqr(SM_TL.get_MVWp()) - Sqr(SM_.get_g2()/SM_TL.get_g2())));
   SM_.set_Ye((2./Sqr(SM_TL.get_v())*Sqr(SM_TL.get_MFe())*(1. - Sqr(SM_.get_v()/SM_TL.get_v()))  + 2./Sqr(SM_TL.get_v())*Sqr(MeMSbar) ).sqrt().matrix().asDiagonal());
   SM_.set_Yu((-(2./Sqr(SM_TL.get_v())*Sqr(SM_TL.get_MFu())*(1. - Sqr(SM_.get_v()/SM_TL.get_v()))  + 2./Sqr(SM_TL.get_v())*Sqr(MuMSbar) ).sqrt()).matrix().asDiagonal());
   SM_.set_Yd((2./Sqr(SM_TL.get_v())*Sqr(SM_TL.get_MFd())*(1. - Sqr(SM_.get_v()/SM_TL.get_v()))  + 2./Sqr(SM_TL.get_v())*Sqr(MdMSbar) ).sqrt().matrix().asDiagonal());
   SM_.set_Lambdax(Sqr(SM_TL.get_Mhh()/SM_TL.get_v())*(1. + MHMSbar2/Sqr(SM_TL.get_Mhh()) - Sqr(SM_.get_v()/SM_TL.get_v())));
   SM_.set_mu2( 1.5*SM_TL.get_Lambdax()*Sqr(SM_TL.get_v())*(-1. + SM_.get_Lambdax()/SM_TL.get_Lambdax() +  Sqr(SM_.get_v()/SM_TL.get_v())) - MHMSbar2);
   SM_.calculate_DRbar_masses();

}

/**
 * matches gauge and Yukawa couplings from SM to @ModelName@ at tree-level
 */
void @ModelName@_SM_matching::matchingReverseTL(@ModelName@_mass_eigenstates& model, SM_mass_eigenstates& SM_)
{
   SM_.calculate_DRbar_masses();
   model.set_scale(SM_.get_scale());
   model.set_@hyperchargeCoupling@(SM_.get_g1()*Sqrt(.6)/@hyperchargeCouplingGutNormalization@);
   model.set_@leftCoupling@(SM_.get_g2()/@leftCouplingGutNormalization@);
   model.set_@strongCoupling@(SM_.get_g3());

   // 'vev' is regarded as keyword for user-definied matching
   const auto vev = SM_.get_v();

@applyUserMatching@

   Eigen::Matrix<double, 3, 3> topDRbar      = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> bottomDRbar   = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> electronDRbar = ZEROMATRIX(3,3);

   for(unsigned gen = 0; gen < 3; gen++)
   {
      topDRbar(gen, gen)      = SM_.get_MFu(gen);
      bottomDRbar(gen, gen)   = SM_.get_MFd(gen);
      electronDRbar(gen, gen) = SM_.get_MFe(gen);
   }

@setYukawas@

   model.calculate_DRbar_masses();
}

/**
 * matches gauge and Yukawa couplings from SM to @ModelName@ at one-loop
 */
void @ModelName@_SM_matching::matchingReverse(@ModelName@_mass_eigenstates& model, SM_mass_eigenstates& SM_)
{
   // match parameter at tree-level first
   matchingReverseTL(model, SM_);
   model.solve_ewsb_one_loop();
   SM_.solve_ewsb_one_loop();

   const double alpha_em = .6 * Sqr(SM_.get_g1() * SM_.get_g2())/(4. * Pi * (.6*Sqr(SM_.get_g1()) + Sqr(SM_.get_g2())));
   const double alpha_s  = Sqr(SM_.get_g3())/(4. * Pi);
   const double currentScale = SM_.get_scale();
@gauge1Linit@
@alphaEM1Lmatching@
@alphaS1Lmatching@

   // one-loop matched masses
   const double MW2_1L = MVWp2matching1Lreverted(SM_, model);
   const double MZ2_1L = MVZ2matching1Lreverted(SM_, model);


   Eigen::Matrix<double, 3, 3> topDRbar      = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> bottomDRbar   = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> electronDRbar = ZEROMATRIX(3,3);

   for( unsigned gen = 0; gen < 3; gen++)
   {
      topDRbar(gen, gen)      = Sqrt(MFu2matching1Lreverted(SM_, model, gen));
      bottomDRbar(gen, gen)   = Sqrt(MFd2matching1Lreverted(SM_, model, gen));
      electronDRbar(gen, gen) = Sqrt(MFe2matching1Lreverted(SM_, model, gen));
   }

   // define and apply 1L-matched gauge parameters
   const double g1_1L = AbsSqrt(4. * Pi * alpha_em * (1. + delta_alpha_em) * MZ2_1L / MW2_1L) / @hyperchargeCouplingGutNormalization@;
   const double g2_1L = AbsSqrt(4. * Pi * alpha_em * (1. + delta_alpha_em) / (1. - MW2_1L/MZ2_1L)) / @leftCouplingGutNormalization@;
   const double g3_1L = AbsSqrt(4. * Pi * alpha_s * (1. + delta_alpha_s));

   model.set_@hyperchargeCoupling@(g1_1L);
   model.set_@leftCoupling@(g2_1L);
   model.set_@strongCoupling@(g3_1L);

   // 'vev' is a keyword for user-defined matching
   const double vev = 2. * Sqrt(MW2_1L) / g2_1L;

@applyUserMatching@
@setYukawas@

   model.calculate_DRbar_masses();
}


@smMediumDiag@
@reverseDiag@

} //namespace flexiblesusy