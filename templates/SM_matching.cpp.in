// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_SM_matching.hpp"
#include "wrappers.hpp"
#include "two_scale_matching.hpp"
#include "SM_mass_eigenstates.hpp"
#include "@ModelName@_mass_eigenstates.hpp"
#include <cmath>

namespace flexiblesusy {

#define MODELPARAMETER(p) model.get_##p()
#define SMPARAMETER(p) SM_.get_##p()
#define INPUTPARAMETER(p) model.get_input().p

/**
 * matches Standardmodel from @ModelName@-Model at tree-level
 */
void @ModelName@_SM_matching::matchingTL(SM_mass_eigenstates& SM_, const @ModelName@_mass_eigenstates& model)
{
  SM_.set_scale(model.get_scale());
  SM_.set_g1(model.get_@hyperchargeCoupling@()*@hyperchargeCouplingGutNormalization@/Sqrt(.6));
  SM_.set_g2(model.get_@leftCoupling@()*@leftCouplingGutNormalization@);
  SM_.set_g3(model.get_@strongCoupling@());
  SM_.set_v(2.*model.get_M@VectorW@()/SM_.get_g2());
  SM_.set_Ye(Sqrt(2.)/SM_.get_v()*model.get_M@Electron@().matrix().asDiagonal());
  SM_.set_Yu(-Sqrt(2.)/SM_.get_v()*model.get_M@TopQuark@().matrix().asDiagonal());
  SM_.set_Yd(Sqrt(2.)/SM_.get_v()*model.get_M@BottomQuark@().matrix().asDiagonal());
  SM_.set_Lambdax(Sqr(model.get_M@HiggsBoson@()@LightestHiggsExtension@)/Sqr(SM_.get_v()));
  SM_.set_mu2( 1.5*SM_.get_Lambdax()*Sqr(SM_.get_v()) - Sqr(model.get_M@HiggsBoson@()@LightestHiggsExtension@));
  SM_.solve_ewsb_tree_level();
  SM_.calculate_DRbar_masses();
}


/**
 * matches Standardmodel from @ModelName@-Model at one-loop-level
 */
void @ModelName@_SM_matching::matching(SM_mass_eigenstates& SM_, @ModelName@_mass_eigenstates& model)
{
   const auto model_pole_mass_order = model.get_pole_mass_loop_order();
   const auto model_momentum_iterations = model.get_number_of_mass_iterations();

   model.set_pole_mass_loop_order(1);
   model.set_number_of_mass_iterations(0);

   model.calculate_DRbar_masses();
   model.solve_ewsb_one_loop();
   model.calculate_Mhh_pole();

   SM_.run_to(model.get_scale());
   SM_.calculate_DRbar_masses();
   SM_.solve_ewsb_one_loop();

   const double p = model.get_M@HiggsBoson@()@LightestHiggsExtension@;
   SM_.set_Lambdax((Sqr(model.get_physical().M@HiggsBoson@@LightestHiggsExtension@) + Re(SM_.self_energy_hh(p) - SM_.get_mass_matrix_hh() + Sqr(SM_.get_Mhh())))/Sqr(SM_.get_v()));

   model.set_pole_mass_loop_order(model_pole_mass_order);
   model.set_number_of_mass_iterations(model_momentum_iterations);

   model.calculate_DRbar_masses();
   model.solve_ewsb();
   SM_.calculate_DRbar_masses();
   SM_.solve_ewsb();

}

/**
 * matches gauge and Yukawa couplings from SM to @ModelName@ at tree-level
 */
void @ModelName@_SM_matching::matchingReverseTL(@ModelName@_mass_eigenstates& model, SM_mass_eigenstates& SM_)
{
   SM_.calculate_DRbar_masses();
   model.set_scale(SM_.get_scale());
   model.set_@hyperchargeCoupling@(SM_.get_g1()*Sqrt(.6)/@hyperchargeCouplingGutNormalization@);
   model.set_@leftCoupling@(SM_.get_g2()/@leftCouplingGutNormalization@);
   model.set_@strongCoupling@(SM_.get_g3());

   // 'vev' is regarded as keyword for user-definied matching
   const auto vev = SM_.get_v();

@applyUserMatching@

   Eigen::Matrix<double, 3, 3> topDRbar      = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> bottomDRbar   = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> electronDRbar = ZEROMATRIX(3,3);

   for(unsigned gen = 0; gen < 3; gen++)
   {
      topDRbar(gen, gen)      = SM_.get_MFu(gen);
      bottomDRbar(gen, gen)   = SM_.get_MFd(gen);
      electronDRbar(gen, gen) = SM_.get_MFe(gen);
   }

@setYukawas@

   model.calculate_DRbar_masses();
}

/**
 * matches gauge and Yukawa couplings from SM to @ModelName@ at one-loop
 */
void @ModelName@_SM_matching::matchingReverse(@ModelName@_mass_eigenstates& model, SM_mass_eigenstates& SM_)
{
   const auto model_pole_mass_order = model.get_pole_mass_loop_order();
   const auto model_momentum_iterations = model.get_number_of_mass_iterations();
   const auto sm_pole_mass_order = SM_.get_pole_mass_loop_order();
   const auto sm_momentum_iterations = SM_.get_number_of_mass_iterations();

   model.set_pole_mass_loop_order(1);
   model.set_number_of_mass_iterations(0);
   SM_.set_pole_mass_loop_order(1);
   SM_.set_number_of_mass_iterations(0);

   model.run_to(SM_.get_scale());
   model.calculate_DRbar_masses();
   model.solve_ewsb_one_loop();

   SM_.calculate_DRbar_masses();
   SM_.solve_ewsb_one_loop();

   const double alpha_em = .6 * Sqr(SM_.get_g1() * SM_.get_g2())/(4. * Pi * (.6*Sqr(SM_.get_g1()) + Sqr(SM_.get_g2())));
   const double alpha_s  = Sqr(SM_.get_g3())/(4. * Pi);
   const double currentScale = SM_.get_scale();
@gauge1Linit@
@alphaEM1Lmatching@
@alphaS1Lmatching@


   model.calculate_DRbar_masses();
   model.solve_ewsb_one_loop();
   model.calculate_M@TopQuark@_pole();
   model.calculate_M@BottomQuark@_pole();
   model.calculate_M@Electron@_pole();
   model.calculate_M@VectorW@_pole();
   model.calculate_M@VectorZ@_pole();

   SM_.calculate_DRbar_masses();
   SM_.solve_ewsb_one_loop();
   SM_.calculate_MFu_pole();
   SM_.calculate_MFd_pole();
   SM_.calculate_MFe_pole();
   SM_.calculate_MVWp_pole();
   SM_.calculate_MVZ_pole();

   // one-loop matched masses
   const double MW2_1L = Sqr(SM_.get_physical().MVWp) - Sqr(model.get_physical().M@VectorW@) + Sqr(model.get_M@VectorW@());
   const double MZ2_1L = Sqr(SM_.get_physical().MVZ) - Sqr(model.get_physical().M@VectorZ@) + Sqr(model.get_M@VectorZ@());


   Eigen::Matrix<double, 3, 3> topDRbar      = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> bottomDRbar   = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> electronDRbar = ZEROMATRIX(3,3);

   for( unsigned gen = 0; gen < 3; gen++)
   {
      topDRbar(gen, gen)      = SM_.get_physical().MFu(gen) - model.get_physical().M@TopQuark@(gen) + model.get_M@TopQuark@(gen);
      bottomDRbar(gen, gen)   = SM_.get_physical().MFd(gen) - model.get_physical().M@BottomQuark@(gen) + model.get_M@BottomQuark@(gen);
      electronDRbar(gen, gen) = SM_.get_physical().MFe(gen) - model.get_physical().M@Electron@(gen) + model.get_M@Electron@(gen);
   }

   // define and apply 1L-matched gauge parameters
   const double g1_1L = AbsSqrt(4. * Pi * alpha_em * (1. + delta_alpha_em) * MZ2_1L / MW2_1L) / @hyperchargeCouplingGutNormalization@;
   const double g2_1L = AbsSqrt(4. * Pi * alpha_em * (1. + delta_alpha_em) / (1. - MW2_1L/MZ2_1L)) / @leftCouplingGutNormalization@;
   const double g3_1L = AbsSqrt(4. * Pi * alpha_s * (1. + delta_alpha_s));

   model.set_@hyperchargeCoupling@(g1_1L);
   model.set_@leftCoupling@(g2_1L);
   model.set_@strongCoupling@(g3_1L);

   // 'vev' is a keyword for user-defined matching
   const double vev = 2. * Sqrt(MZ2_1L/(.6*Sqr(g1_1L) + Sqr(g2_1L)));

@applyUserMatching@
@setYukawas@

   model.set_pole_mass_loop_order(model_pole_mass_order);
   model.set_number_of_mass_iterations(model_momentum_iterations);
   SM_.set_pole_mass_loop_order(sm_pole_mass_order);
   SM_.set_number_of_mass_iterations(sm_momentum_iterations);

   model.calculate_DRbar_masses();
   model.solve_ewsb();
   SM_.calculate_DRbar_masses();
   SM_.solve_ewsb();

}


@smMediumDiag@
@reverseDiag@

} //namespace flexiblesusy