// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_cxx_diagrams.hpp
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */

#ifndef @ModelName@_CXXDIAGRAMS_H
#define @ModelName@_CXXDIAGRAMS_H

#include "numerics2.hpp"
#include "wrappers.hpp"
#include "multiindex.hpp"
#include "concatenate.hpp"

#include <array>

#include <boost/array.hpp>
#include <boost/version.hpp>
#include <boost/range/join.hpp>

#include <boost/mpl/erase.hpp>
#include <boost/mpl/vector_c.hpp>
#include <boost/mpl/joint_view.hpp>

#include <boost/fusion/adapted/mpl.hpp>
#include <boost/fusion/include/vector.hpp>
#include <boost/fusion/adapted/boost_array.hpp>

#if BOOST_VERSION >= 105800
#include <boost/fusion/include/move.hpp>
#else
#include <boost/fusion/include/copy.hpp>
#endif

#define INPUTPARAMETER(p) context.model.get_input().p
#define MODELPARAMETER(p) context.model.get_##p()
#define DERIVEDPARAMETER(p) context.model.p()
#define PHASE(p) context.model.get_##p()

namespace flexiblesusy {
namespace cxx_diagrams {

// Declare a type that can hold the field indices for any given field
template<class Field> struct field_indices {
   using type = std::array<int, Field::numberOfFieldIndices>;
};

namespace detail
{
  template<class Field>
  struct number_of_field_indices
  {
    static constexpr int value =
      std::tuple_size<typename field_indices<Field>::type>::value;
    using type = boost::mpl::int_<value>;
  };

  template<class Sequence>
  struct total_number_of_field_indices
  {
    using type = typename boost::mpl::fold<
      Sequence,
      boost::mpl::int_<0>,
      boost::mpl::plus<
        boost::mpl::_1,
        number_of_field_indices<
          boost::mpl::_2
        >
      >
    >::type;
    static constexpr int value = type::value;
  };
}

template<class Field> struct bar
{
  using index_bounds = typename Field::index_bounds;
  static constexpr int numberOfGenerations = Field::numberOfGenerations;
  using sm_flags = typename Field::sm_flags;
  static constexpr int numberOfFieldIndices = Field::numberOfFieldIndices;
  static constexpr double electric_charge = - Field::electric_charge;
  using lorentz_conjugate = Field;

  using type = bar<Field>;
};

template<class Field> struct conj
{
  using index_bounds = typename Field::index_bounds;
  static constexpr int numberOfGenerations = Field::numberOfGenerations;
  using sm_flags = typename Field::sm_flags;
  static constexpr int numberOfFieldIndices = Field::numberOfFieldIndices;
  static constexpr double electric_charge = - Field::electric_charge;
  using lorentz_conjugate = Field;

  using type = conj<Field>;
};

// Double Lorentz conjugation
template<class Field> struct bar<bar<Field>> {
   using type = Field;
};
template<class Field> struct conj<conj<Field>> {
   using type = Field;
};

// Remove Lorentz conjugation
template<class Field> struct remove_lorentz_conjugation {
   using type = Field;
};

template<class Field> struct remove_lorentz_conjugation<bar<Field>> {
   using type = Field;
};

template<class Field> struct remove_lorentz_conjugation<conj<Field>> {
   using type = Field;
};


template<class Field>
typename std::enable_if<
  Field::numberOfGenerations != 1,
  bool
>::type
isSMField(const typename field_indices<Field>::type& indices)
{
  boost::array<bool, Field::numberOfGenerations> sm_flags;

#if BOOST_VERSION >= 105800
  boost::fusion::move(typename Field::sm_flags(), sm_flags);
#else
  boost::fusion::copy(typename Field::sm_flags(), sm_flags);
#endif

  return sm_flags[indices.front()];
}

template<class Field>
typename std::enable_if<
  Field::numberOfGenerations == 1,
  bool
>::type
isSMField(const typename field_indices<Field>::type &)
{
  return boost::mpl::at_c<
    typename Field::sm_flags,
    0
  >::type::value;
}

namespace detail
{
template<class Begin, class End>
decltype(
  boost::make_iterator_range(
    multiindex<Begin, End>::begin(),
    multiindex<Begin, End>::end()
  )
)
make_index_range( void )
{
  using index = multiindex<Begin, End>;

  return boost::make_iterator_range(
    index::begin(), index::end()
  );
}
}

template<class ObjectWithIndexBounds>
struct index_bounds_of
{
  using type = typename ObjectWithIndexBounds::index_bounds;
};

template<class ObjectWithIndexBounds>
decltype(detail::make_index_range<
  typename index_bounds_of<ObjectWithIndexBounds>::type::first,
  typename index_bounds_of<ObjectWithIndexBounds>::type::second
>())
index_range( void )
{
  return detail::make_index_range<
    typename index_bounds_of<ObjectWithIndexBounds>::type::first,
    typename index_bounds_of<ObjectWithIndexBounds>::type::second
  >();
}

@CXXDiagrams_Fields@

class ScalarVertex {
private:
  std::complex<double> val;
public:
  ScalarVertex(std::complex<double> v)
  : val(v) {}

  std::complex<double> value() const
  {
     return val;
  }

  bool isZero() const
  {
    return (is_zero(val.real()) && is_zero(val.imag()));
  }
};

class ChiralVertex {
private:
  std::pair<std::complex<double>, std::complex<double>> value;
public:
  ChiralVertex(const std::complex<double>& left,
               const std::complex<double>& right)
  : value(left, right) {}

  std::complex<double> left() const
  {
     return value.first;
  }

  std::complex<double> right() const
  {
     return value.second;
  }

  bool isZero() const
  {
    return (is_zero(value.first.real()) && is_zero(value.first.imag()) &&
            is_zero(value.second.real()) && is_zero(value.second.imag()));
  }
};

class MomentumDifferenceVertex {
private:
  std::complex<double> val;
  int minuendIndex;
  int subtrahendIndex;
public:
  MomentumDifferenceVertex(std::complex<double> v, int mi, int si )
  : val(v), minuendIndex(mi), subtrahendIndex(si) {}

  std::complex<double> value(int mi, int si) const
  {
    if( mi == minuendIndex && si == subtrahendIndex )
      return val;
    if( mi == subtrahendIndex && si == minuendIndex )
      return -val;

    throw std::invalid_argument(
       "MomentumDifferenceVertex: Wrong index combination" );
    return 0.0;
  }

  bool isZero() const
  {
    return (is_zero(val.real()) && is_zero(val.imag()));
  }
};

class InverseMetricVertex {
private:
  std::complex<double> val;
public:
  InverseMetricVertex(std::complex<double> v)
  : val(v) {}

  std::complex<double> value() const
  {
    return val;
  }

  bool isZero() const
  {
    return (is_zero(val.real()) && is_zero(val.imag()));
  }
};

/**
 * @class VertexData<F...>
 * @brief VertexData data for a vertex with the fields specified by F....
 */
template<class ...Fields> struct VertexData;

struct EvaluationContext;

template<class ...Fields> class Vertex {
  using Data = VertexData<Fields...>;
public:
  using index_bounds = typename boost::mpl::fold<
    boost::mpl::vector<Fields...>,
    boost::mpl::pair<
      boost::mpl::vector<>,
      boost::mpl::vector<>
    >,
    boost::mpl::pair<
      boost::mpl::joint_view<
        boost::mpl::first<boost::mpl::_1>,
        boost::mpl::first<
          index_bounds_of<boost::mpl::_2>
        >
      >,
      boost::mpl::joint_view<
        boost::mpl::second<boost::mpl::_1>,
        boost::mpl::second<
          index_bounds_of<boost::mpl::_2>
        >
      >
    >
  >::type;
  using indices_type = std::array<
    int,
    detail::total_number_of_field_indices<
      boost::mpl::vector<Fields...>
    >::value
  >;
  using vertex_type = typename Data::vertex_type;

  template<int FieldIndex>
  static typename field_indices<
    typename boost::mpl::at_c<
      boost::mpl::vector<Fields...>,
      FieldIndex
    >::type
  >::type 
  field_indices(const indices_type& indices)
  {
    using namespace boost::mpl;
    using fields = vector<Fields...>;

    using result_type = typename field_indices<
      typename boost::mpl::at_c<fields, FieldIndex>::type
    >::type;

    using preceeding_fields = typename erase<
      fields,
      typename advance<
        typename begin<fields>::type,
        int_<FieldIndex>
      >::type,
      typename end<fields>::type
    >::type;

    constexpr int offset = detail::total_number_of_field_indices<
      preceeding_fields
    >::value;
    constexpr int length = std::tuple_size<result_type>::value;

    result_type result_indices;
    std::copy( indices.begin() + offset,
               indices.begin() + offset + length,
               result_indices.begin() );
    return result_indices;
  }

  static vertex_type evaluate(const indices_type& indices,
    const EvaluationContext& context);
};


/**
* @class EvaluationContext
* @brief Represents an evaluation context.
*
* It simply contains a reference to a model object.
* All computational functions are forwarded to that object,
* e.g. mass calculation functions.
*/
struct EvaluationContext {
   @ModelName@_mass_eigenstates& model; ///< The model object.

   template<class Field>
   double mass(const typename field_indices<Field>::type& indices) const
   {
      using CleanField = typename remove_lorentz_conjugation<Field>::type;
      return mass_impl<CleanField>(indices);
   }

private:
   template<class Field>
   double mass_impl(const typename field_indices<Field>::type& indices) const;
};


@CXXDiagrams_VertexData@


@CXXDiagrams_Vertices@


@CXXDiagrams_MassFunctions@

namespace impl {
@CXXDiagrams_UnitCharge@
}

static double unit_charge(const EvaluationContext& context)
{
   return -impl::unit_charge(context).left().real() / Electron::electric_charge;
}

} // namespace cxx_diagrams
} // namespace flexiblesusy

#undef INPUTPARAMETER
#undef MODELPARAMETER
#undef DERIVEDPARAMETER
#undef PHASE

#endif
