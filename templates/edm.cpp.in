// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_edm.cpp
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */

#include "@ModelName@_edm.hpp"
#include "@ModelName@_mass_eigenstates.hpp"

#include "numerics2.hpp"
#include "wrappers.hpp"

#include <array>
#include <vector>
#include <boost/mpl/vector_c.hpp>
#include <boost/mpl/at.hpp>

#define INPUTPARAMETER(p) context.model.get_input().p
#define MODELPARAMETER(p) context.model.get_##p()
#define DERIVEDPARAMETER(p) context.model.p()

using namespace flexiblesusy;

namespace {
/**
 * @class IndexBounds<N>
 * @brief A class representing multiple (N) index ranges.
 *
 * N is a non-negative integer.
 * The ranges are specified the c++ way; The range begins are inclusive
 * and the range ends are exclusive. Misspecified ranges result in
 * undefined behaviour!
 * The intended use is to iterate over an IndexBounds<N> using the normal
 * begin()/end() syntax, which will iterate over every possible combination
 * of the indices within their respective ranges.
 * The ranges are const! Once they are initialized they cannot be changed.
 * Initialization is done like = {{ beg1, beg2, ... }, { end1, end2, ... }}
 */
template<unsigned N> struct IndexBounds;

/**
 * @class IndexIterator<N>
 * @brief The iterator class used by IndexBounds<N>.
 *
 * It only fulfils the input iterator requirements!
 * The value_type is a const std::array<unsigned, N>
 * containing the current indices.
 * Incrementing the iterator results in a new index combination.
 */
template<unsigned N> struct IndexIterator
: public std::iterator<
std::input_iterator_tag,
const std::array<unsigned, N>>
{
   friend class IndexBounds<N>;
private:
   const IndexBounds<N> *bounds;
   std::array<unsigned, N> indices;

   IndexIterator(const IndexBounds<N> &b, const unsigned *i)
      : bounds(&b)
   {
      std::memcpy(indices.data(), i, N * sizeof(unsigned));
   }
public:
   const std::array<unsigned, N> &operator*() const {
      return indices;
   }

   const std::array<unsigned, N> *operator->() const {
      return &indices;
   }

   IndexIterator &operator++() {
      for (unsigned i = 0; i != N; i++) {
         indices[i]++;
         if (indices[i] == bounds->indexEnd[i]) {
            indices[i] = bounds->indexBegin[i];
            continue;
         }

         return *this;
      }

      std::memcpy(indices.data(), bounds->indexEnd, N * sizeof(unsigned));
      return *this;
   }

   IndexIterator operator++(int) {
      IndexIterator it(*this);
      this->operator++();
      return it;
   }

   template<unsigned M>
   friend bool operator==(const IndexIterator<M> &it1, const IndexIterator<M> &it2);
};

template<unsigned N>
bool operator==(const IndexIterator<N> &it1, const IndexIterator<N> &it2)
{
   return it1.indices == it2.indices;
}

template<unsigned N>
bool operator!=(const IndexIterator<N> &it1, const IndexIterator<N> &it2)
{
   return !(it1 == it2);
}

template<unsigned N> struct IndexBounds {
   typedef const std::array<unsigned, N> indices_type;

   unsigned indexBegin[N];
   unsigned indexEnd[N];

   typedef IndexIterator<N> const_iterator;

   const_iterator begin() const {
      return const_iterator(*this, indexBegin);
   }

   const_iterator end() const {
      return const_iterator(*this, indexEnd);
   }
};

template<> struct IndexBounds<0> {
   typedef const std::array<unsigned, 0> indices_type;
   typedef indices_type * const_iterator;

   static const indices_type dummyIndex;

   const_iterator begin() const
   { return &dummyIndex; }
   const_iterator end() const
   { return (begin()+1); }
};
IndexBounds<0>::indices_type IndexBounds<0>::dummyIndex{};

@EDM_Fields@

template<class F> struct remove_anti { typedef F type; };
template<class F> struct remove_anti<anti<F>> { typedef F type; };

/**
 * @class EvaluationContext
 * @brief Represents an evaluation context.
 *
 * Actually it simply contains a reference to a model object.
 * All computational functions are forwarded to that object,
 * e.g. mass calculation functions.
 */
struct EvaluationContext {
   @ModelName@_mass_eigenstates& model; ///< The model object.

   /**
    * @fn mass<F>
    * @brief Returns the mass of a field.
    */
   template<class F> double mass() const {
      return mass<typename anti<F>::type>();
   }

   template<class F> double mass(unsigned index) const {
      return mass<typename anti<F>::type>(index);
   }
};

/**
 * @class DiagramEvaluator
 * @brief A template that can calculate disagrams.
 *
 * This template is completely general. The intended use is
 * to have specialisations of the kind:
 *   DiagramEvaluator<DiagramType, Field1, Field2, ...>
 * along with a static member function:
 *   static double value( EvaluationContext &context );
 * that calculates the contribution to the edm
 * for a specific diagram class with specified fields.
 */
template<class ...Args> struct DiagramEvaluator;

double OneLoopFunctionF1C(double);
double OneLoopFunctionF2C(double);
double OneLoopFunctionF1N(double);
double OneLoopFunctionF2N(double);

@EDM_ChargeGetters@

@EDM_Diagrams@

/**
 * @class SingleComponentedVertex
 * @brief A vertex whose value can be represented by a single complex number
 */
class SingleComponentedVertex {
private:
   std::complex<double> val; ///< The value
public:
   SingleComponentedVertex(std::complex<double> v)
      : val(v) {}

   /**
    * @fn value
    * @brief Returns the value of the vertex.
    */
   std::complex<double> value() const {
      return val;
   }

   /**
    * @fn isZero
    * @brief Tests whether the value is numerically significant
    */
   bool isZero() const {
      return (is_zero(val.real()) && is_zero(val.imag()));
   }
};

/**
 * @class LeftAndRightComponentedVertex
 * @brief A vertex whose value can be represented by two complex numbers
 */
class LeftAndRightComponentedVertex {
private:
   std::pair<std::complex<double>, std::complex<double>> value;  ///< The values
public:
   LeftAndRightComponentedVertex(const std::complex<double> &left,
                                 const std::complex<double> &right)
      : value(left, right) {}

   /**
    * @fn left
    * @brief Returns the left component of the vertex.
    */
   std::complex<double> left() const {
      return value.first;
   }

   /**
    * @fn right
    * @brief Returns the left component of the vertex.
    */
   std::complex<double> right() const {
      return value.second;
   }

   /**
    * @fn isZero
    * @brief Tests whether the values are numerically significant
    */
   bool isZero() const {
      return (is_zero(value.first.real()) && is_zero(value.first.imag()) &&
              is_zero(value.second.real()) && is_zero(value.second.imag()));
   }
};

/**
 * @class VertexFunctionData<F...>
 * @brief Vertex data for a vertex with the fields specified by F...
 *
 * All elements in F... have to be publicly derived from Field.
 * The data includes the type of the vertex, whether F... is in
 * canonical order or permuted as well as index bounds referring to
 * the specific fields (generation and colour indices, etc).
 * The intention is to have a program generate VertexFunctionData<>
 * specialisations that are then used by the VertexFunction<> template.
 */
template<class ...F> struct VertexFunctionData;

/**
 * @class VertexFunction<F...>
 * @brief A template that represents a vertex with open field indices.
 *
 * All elements in F... have to be publicly derived from Field.
 * To obtain a conrete value, use the static member function vertex()
 * along with the desired field indices.
 */
template<class ...F> class VertexFunction {
   using Data = VertexFunctionData<F...>;
public:
   using index_bounds = typename Data::index_bounds;
   using indices_type = typename index_bounds::indices_type;
   using vertex_type = typename Data::vertex_type;

   using fieldIndexStart = typename Data::fieldIndexStart;

   /**
    * @fn indexBounds
    * @brief Returns the IndexBounds<> object of the VertexFunction.
    */
   static const index_bounds &indexBounds() {
      return indexB;
   }

   /**
    * @fn fieldIndices
    * @brief Returns the subset of indices belonging to
    *        a field at a given index.
    * @param indices The complete set of indices for all fields
    *
    * The field indexing is in the same order as the template arguments
    * and starts at 0.
    */
   template<unsigned fieldIndex>
   static std::vector<unsigned> fieldIndices(const indices_type &indices)
   {
      auto begin = indices.begin() + boost::mpl::at_c<fieldIndexStart, fieldIndex>::type::value;
      auto end = indices.begin() + boost::mpl::at_c<fieldIndexStart, fieldIndex+1>::type::value;
      return std::vector<unsigned>(begin, end);
   }

   /**
    * @fn vertex
    * @brief Calculates the vertex for a given set of field indices.
    * @param indices The field indices
    * @param context The evaluation context
    */
   static vertex_type vertex(const indices_type &indices, EvaluationContext &context);
};

@EDM_VertexFunctionData@
}

@EDM_Calculation@

double @ModelName@_edm::calculate_edm_electron(const @ModelName@_mass_eigenstates& model_)
{
   // make copy since model is modified via call to calculate_MFe_pole()
   @ModelName@_mass_eigenstates model(model_);

   return edm<Electron>( model );
}

namespace {
/**
* @defgroup LoopFunctions
* @brief The loop functions necessary for \f$a_\mu\f$ one-loop calculations.
*
* These are OneLoopFunctionF1C(), OneLoopFunctionF2C(),
* OneLoopFunctionF1N() and OneLoopFunctionF2N()
* as specified in arXiv:1311.1775
*/

double OneLoopFunctionF1C(double x)
{
   if (is_zero(x))
      return 4.0;

   // error around x=1 is <= 10^-12 on an intel i7
   const double y = x - 1.0;

   if (std::abs(y) < 0.21) {
      return (1.0000000000000000000 -
              0.60000000000000000000  * y +
              0.40000000000000000000  * y * y -
              0.28571428571428571429  * y * y * y +
              0.21428571428571428571  * y * y * y * y -
              0.16666666666666666667  * y * y * y * y * y +
              0.13333333333333333333  * y * y * y * y * y * y -
              0.10909090909090909091  * y * y * y * y * y * y * y +
              0.090909090909090909091 * y * y * y * y * y * y * y * y -
              0.076923076923076923077 * y * y * y * y * y * y * y * y * y +
              0.065934065934065934066 * y * y * y * y * y * y * y * y * y * y -
              0.057142857142857142857 * y * y * y * y * y * y * y * y * y * y * y +
              0.050000000000000000000 * y * y * y * y * y * y * y * y * y * y * y * y -
              0.044117647058823529412 * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.039215686274509803922 * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.035087719298245614035 * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   }

   return 2.0 / (y * y * y * y) * (2.0 + 3.0 * x - 6.0 * x * x + x * x * x + 6.0 * x * std::log(x));
}

double OneLoopFunctionF2C(double x)
{
   // error around x=1 is <= 10^-13 on an intel i7
   const double y = x - 1.0;

   if (std::abs(y) < 0.155)
      return (1.0 - 0.75 * y + 0.6 * y * y -
              0.50000000000000000000 * y * y * y +
              0.4285714285714285714  * y * y * y * y -
              0.37500000000000000000 * y * y * y * y * y +
              0.33333333333333333333 * y * y * y * y * y * y -
              0.3000000000000000000  * y * y * y * y * y * y * y +
              0.2727272727272727273  * y * y * y * y * y * y * y * y -
              0.2500000000000000000  * y * y * y * y * y * y * y * y * y +
              0.23076923076923076923 * y * y * y * y * y * y * y * y * y * y -
              0.21428571428571428571 * y * y * y * y * y * y * y * y * y * y * y +
              0.2000000000000000000  * y * y * y * y * y * y * y * y * y * y * y * y -
              0.1875000000000000000  * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.1764705882352941176  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.16666666666666666667 * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);

   return -3.0 / (2.0 * y * y * y) * (-3.0 + 4.0 * x - x * x - 2.0 * std::log(x));
}

double OneLoopFunctionF1N(double x)
{
   if (is_zero(x))
      return 2.0;

   // error around x=1 is <= 10^-12 on an intel i7
   const double y = x - 1.0;

   if (std::abs(y) < 0.23)
      return (1.0000000000000000000 -
              0.4000000000000000000  * y +
              0.2000000000000000000  * y * y -
              0.11428571428571428571 * y * y * y +
              0.07142857142857142857 * y * y * y * y -
              0.04761904761904761905 * y * y * y * y * y +
              0.03333333333333333333 * y * y * y * y * y * y -
              0.02424242424242424242 * y * y * y * y * y * y * y +
              0.0181818181818181818  * y * y * y * y * y * y * y * y -
              0.01398601398601398601 * y * y * y * y * y * y * y * y * y +
              0.01098901098901098901 * y * y * y * y * y * y * y * y * y * y -
              0.0087912087912087912  * y * y * y * y * y * y * y * y * y * y * y +
              0.00714285714285714286 * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0058823529411764706  * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.0049019607843137255  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0041279669762641899  * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);

   return 2.0 / (y * y * y * y) * (1.0 - 6.0 * x + 3.0 * x * x + 2.0 * x * x * x - 6.0 * x * x * std::log(x));
}

double OneLoopFunctionF2N(double x)
{
   if (is_zero(x))
      return 3.0;

   // error around x=1 is <= 10^-13 on an intel i7
   const double y = x - 1.0;

   if (std::abs(y) < 0.185)
      return (1.0000000000000000000 -
              0.50000000000000000000 * y +
              0.30000000000000000000 * y * y -
              0.2000000000000000000  * y * y * y +
              0.14285714285714285714 * y * y * y * y -
              0.10714285714285714286 * y * y * y * y * y +
              0.08333333333333333333 * y * y * y * y * y * y -
              0.06666666666666666667 * y * y * y * y * y * y * y +
              0.05454545454545454545 * y * y * y * y * y * y * y * y -
              0.0454545454545454545  * y * y * y * y * y * y * y * y * y +
              0.0384615384615384615  * y * y * y * y * y * y * y * y * y * y -
              0.03296703296703296703 * y * y * y * y * y * y * y * y * y * y * y +
              0.0285714285714285714  * y * y * y * y * y * y * y * y * y * y * y * y -
              0.02500000000000000000 * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.0220588235294117647  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0196078431372549020  * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);

   return -3.0 / (y * y * y) * (1.0 - x * x + 2.0 * x * std::log(x));
}

@EDM_Definitions@

template<class EDMField, class PhotonEmitter, class ExchangeField>
double DiagramEvaluator<OneLoopDiagram<0>,
   EDMField, PhotonEmitter, ExchangeField
>::value(EvaluationContext &context)
{
   double res = 0.0;


   return res;
}

template<class EDMField, class PhotonEmitter, class ExchangeField>
double DiagramEvaluator<OneLoopDiagram<1>,
   EDMField, PhotonEmitter, ExchangeField
>::value(EvaluationContext &context)
{
   double res = 0.0;



   return res;
}
}
