// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_effective_couplings.hpp"

#include "effective_couplings.hpp"
#include "standard_model.hpp"
#include "wrappers.hpp"

namespace flexiblesusy {

using namespace effective_couplings;

#define INPUTPARAMETER(parameter) model.get_input().parameter
#define MODELPARAMETER(parameter) model.get_##parameter()
#define DERIVEDPARAMETER(parameter) model.##parameter()
#define PHASE(parameter) model.get_##parameter()
#define PHYSICAL(parameter) model.get_physical().parameter
#define MODEL model
#define MZDRbar sm->get_MVZ()
#define MWDRbar sm->get_MVWp()

@ModelName@_effective_couplings::@ModelName@_effective_couplings(
   const @ModelName@_mass_eigenstates& model_,
   const softsusy::QedQcd& qedqcd_,
   const Physical_input& input_)
   : model(model_), qedqcd(qedqcd_), physical_input(input_)
   , rg_improve(true), include_qcd_corrections(true)
@mixingMatricesInit@
@loopCouplingsInit@
{
}

@ModelName@_effective_couplings::~@ModelName@_effective_couplings()
{
}

void @ModelName@_effective_couplings::calculate_effective_couplings()
{
@calculateLoopCouplings@
}

void @ModelName@_effective_couplings::set_model(const @ModelName@_mass_eigenstates& model_)
{
   model = model_;
   copy_mixing_matrices_from_model();
}

void @ModelName@_effective_couplings::copy_mixing_matrices_from_model()
{
@copyMixingMatrices@
}

void @ModelName@_effective_couplings::run_SM_parameters_to(double m)
{
   using namespace standard_model;

   Standard_model sm;

   sm.set_loops(2);
   sm.set_thresholds(0);
   sm.set_low_energy_data(qedqcd);
   sm.set_physical_input(physical_input);

   sm.initialise_from_input();
   sm.run_to(m);

   // ensure on-shell SM vev and top mass
   sm.set_v(1.0 / Sqrt(qedqcd.displayFermiConstant() * Sqrt(2.0)));
   sm.set_Yu(2, 2, -Sqrt(2.0) * qedqcd.displayPoleMt() / sm.get_v());
   sm.calculate_DRbar_masses();

   Low_scale_matching matching;
   matching.model = &model;
   matching.sm = &sm;
   matching.match_model_to_SM();
}

void @ModelName@_effective_couplings::run_SM_strong_coupling_to(double m)
{
   using namespace standard_model;

   Standard_model sm;

   sm.set_loops(2);
   sm.set_thresholds(0);
   sm.set_low_energy_data(qedqcd);
   sm.set_physical_input(physical_input);

   sm.initialise_from_input();
   sm.run_to(m);

@setSMStrongCoupling@
}

void @ModelName@_effective_couplings::Low_scale_matching::match_model_to_SM()
{
@applyLowScaleConstraint@
}

void @ModelName@_effective_couplings::Low_scale_matching::set_@UpYukawa@_from_SM()
{
   Eigen::Matrix<std::complex<double>,3,3> topDRbar(ZEROMATRIXCOMPLEX(3,3));
   topDRbar(0,0)      = sm->get_MFu(0);
   topDRbar(1,1)      = sm->get_MFu(1);
   topDRbar(2,2)      = sm->get_MFu(2);

@setDRbarUpQuarkYukawaCouplings@
}

void @ModelName@_effective_couplings::Low_scale_matching::set_@DownYukawa@_from_SM()
{
   Eigen::Matrix<std::complex<double>,3,3> bottomDRbar(ZEROMATRIXCOMPLEX(3,3));
   bottomDRbar(0,0)   = sm->get_MFd(0);
   bottomDRbar(1,1)   = sm->get_MFd(1);
   bottomDRbar(2,2)   = sm->get_MFd(2);

@setDRbarDownQuarkYukawaCouplings@
}

void @ModelName@_effective_couplings::Low_scale_matching::set_@ElectronYukawa@_from_SM()
{
   Eigen::Matrix<std::complex<double>,3,3> electronDRbar(ZEROMATRIXCOMPLEX(3,3));
   electronDRbar(0,0) = sm->get_MFe(0);
   electronDRbar(1,1) = sm->get_MFe(1);
   electronDRbar(2,2) = sm->get_MFe(2);

@setDRbarElectronYukawaCouplings@
}

std::complex<double> @ModelName@_effective_couplings::scalar_scalar_qcd_factor(double m_decay, double m_loop) const
{
   std::complex<double> result(1.0, 0.0);

   if (include_qcd_corrections) {
@calculateScalarScalarLoopQCDFactor@
   }

   return result;
}

std::complex<double> @ModelName@_effective_couplings::scalar_fermion_qcd_factor(double m_decay, double m_loop) const
{
   std::complex<double> result(1.0, 0.0);

   if (include_qcd_corrections) {
@calculateScalarFermionLoopQCDFactor@
   }

   return result;
}

std::complex<double> @ModelName@_effective_couplings::pseudoscalar_fermion_qcd_factor(double m_decay, double m_loop) const
{
   std::complex<double> result(1.0, 0.0);

   if (include_qcd_corrections) {
@calculatePseudoscalarFermionLoopQCDFactor@
   }

   return result;
}

double @ModelName@_effective_couplings::number_of_active_flavours(double m) const
{
   if (m < qedqcd.displayMbMb()) {
      return 4.0;
   } else if (m < qedqcd.displayPoleMt()) {
      return 5.0;
   } else {
      return 6.0;
   }
}

double @ModelName@_effective_couplings::scalar_scaling_factor(double m) const
{
   const double Nf = number_of_active_flavours(m);
   const double mtpole = qedqcd.displayPoleMt();
   const double l = Log(Sqr(m) / Sqr(mtpole));

@calculateScalarQCDScalingFactor@
   return Sqrt(1.0 + nlo_qcd + nnlo_qcd + nnnlo_qcd);
}

double @ModelName@_effective_couplings::pseudoscalar_scaling_factor(double m) const
{
   const double Nf = number_of_active_flavours(m);
   const double mtpole = qedqcd.displayPoleMt();
   const double l = Log(Sqr(m) / Sqr(mtpole));

@calculatePseudoscalarQCDScalingFactor@
   return Sqrt(1.0 + nlo_qcd + nnlo_qcd + nnnlo_qcd);
}

@partialWidthGetters@
@loopCouplingsFunctions@
} // namespace flexiblesusy
