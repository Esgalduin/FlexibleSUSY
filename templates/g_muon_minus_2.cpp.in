// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_g_muon_minus_2.cpp
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */

#include "@ModelName@_g_muon_minus_2.hpp"
#include "@ModelName@_mass_eigenstates.hpp"

#include "config.h"
#include "numerics2.hpp"

#include <array>
#include <vector>
#include <boost/mpl/vector_c.hpp>
#include <boost/mpl/at.hpp>

/* Due to g++4.4 compatibility, we need the following workarounds:
- no variadic non-template parameter packs :'-(
- no constexpr (less code, no boost workarounds...) :'-(
- We have to use typedef instead of using
- no extended friend syntax
- no nullptr
- no extended using syntax
*/

using namespace flexiblesusy;

namespace {
/**
 * @class IndexBounds<N>
 * @brief A class representing multiple (N) index ranges.
 *
 * N is a non-negative integer.
 * The ranges are specified the c++ way; The range begins are inclusive
 * and the range ends are exclusive. Misspecified ranges result in
 * undefined behaviour!
 * The intended use is to iterate over an IndexBounds<N> using the normal
 * begin()/end() syntax, which will iterate over every possible combination
 * of the indices within their respective ranges.
 * The ranges are const! Once they are initialized they cannot be changed.
 * Initialization is done like = {{ beg1, beg2, ... }, { end1, end2, ... }}
 */
template<unsigned int N> struct IndexBounds;

/**
 * @class IndexIterator<N>
 * @brief The iterator class used by IndexBounds<N>.
 *
 * It only fulfils the input iterator requirements!
 * The value_type is a const std::array<unsigned int, N>
 * containing the current indices.
 * Incrementing the iterator results in a new index combination.
 */
template<unsigned int N> struct IndexIterator
: public std::iterator<
std::input_iterator_tag,
const std::array<unsigned int, N>>
{
   friend class IndexBounds<N>;
private:
   const IndexBounds<N> *bounds;
   std::array<unsigned int, N> indices;

   IndexIterator(const IndexBounds<N> &b, const unsigned int *i)
      : bounds(&b)
   {
      std::memcpy(indices.data(), i, N * sizeof(unsigned int));
   }
public:
   const std::array<unsigned int, N> &operator*() const
   {
      return indices;
   }

   const std::array<unsigned int, N> *operator->() const
   {
      return &indices;
   }

   IndexIterator &operator++()
   {
      for (unsigned int i = 0; i != N; i++) {
         indices[i]++;
         if (indices[i] == bounds->indexEnd[i]) {
            indices[i] = bounds->indexBegin[i];
            continue;
         }

         return *this;
      }

      std::memcpy(indices.data(), bounds->indexEnd, N * sizeof(unsigned int));
      return *this;
   }

   IndexIterator operator++(int)
   {
      IndexIterator it(*this);
      this->operator++();
      return it;
   }

   template<unsigned int M>
   friend bool operator==(const IndexIterator<M> &it1, const IndexIterator<M> &it2);
};

template<unsigned int N>
bool operator==(const IndexIterator<N> &it1, const IndexIterator<N> &it2)
{
   return it1.indices == it2.indices;
}

template<unsigned int N>
bool operator!=(const IndexIterator<N> &it1, const IndexIterator<N> &it2)
{
   return !(it1 == it2);
}

template<unsigned int N> struct IndexBounds {
   typedef const std::array<unsigned int, N> indices_type;

   unsigned int indexBegin[N];
   unsigned int indexEnd[N];

   typedef IndexIterator<N> const_iterator;

   const_iterator begin() const
   {
      return const_iterator(*this, indexBegin);
   }

   const_iterator end() const
   {
      return const_iterator(*this, indexEnd);
   }
};

template<> struct IndexBounds<0> {
   typedef const std::array<unsigned int, 0> indices_type;
   typedef indices_type * const_iterator;

   static const indices_type dummyIndex;

   const_iterator begin() const
   { return &dummyIndex; }
   const_iterator end() const
   { return (begin()+1); }
};
IndexBounds<0>::indices_type IndexBounds<0>::dummyIndex = {};

@GMuonMinus2_Particles@

/**
 * @class EvaluationContext
 * @brief Represents an evaluation context.
 *
 * Actually it simply contains a reference to a model object.
 * All computational functions are forwarded to that object,
 * e.g. mass calculation functions.
 */
struct EvaluationContext {
   @ModelName@_mass_eigenstates& model; ///< The model object.

   /**
    * @fn mass<P>
    * @brief Returns the mass of a particle.
    */
   template<class P> double mass() const;
   template<class P> double mass(unsigned int) const;
};

template<class P> double EvaluationContext::mass() const
{
   return mass<typename anti<P>::type>();
}
template<class P> double EvaluationContext::mass(unsigned int index) const
{
   return mass<typename anti<P>::type>(index);
}

/**
 * @class DiagramEvaluator
 * @brief A template that can calculate disagrams.
 *
 * This template is completely general. The intended use is
 * to have specialisations of the kind:
 *   DiagramEvaluator<DiagramType, Particle1, Particle2, ...>
 * along with a static member function:
 *   static double value( EvaluationContext &context );
 * that calculates the contribution to a_muon
 * for a specific diagram class with specified particles.
 */
template<class ...Args> struct DiagramEvaluator;

double OneLoopFunctionF1C(double x);
double OneLoopFunctionF2C(double x);
double OneLoopFunctionF1N(double x);
double OneLoopFunctionF2N(double x);

@GMuonMinus2_MuonFunctionPrototypes@

@GMuonMinus2_Diagrams@

/**
 * @class SingleComponentedVertex
 * @brief A vertex whose value can be represented by a single complex number
 */
class SingleComponentedVertex {
private:
   std::complex<double> val; ///< The value
public:
   SingleComponentedVertex(std::complex<double> v)
      : val(v) {}

   /**
    * @fn value
    * @brief Returns the value of the vertex.
    */
   std::complex<double> value() const
   {
      return val;
   }

   /**
    * @fn isZero
    * @brief Tests whether the value is numerically significant
    */
   bool isZero() const
   {
      return (is_zero(val.real()) && is_zero(val.imag()));
   }
};

/**
 * @class LeftAndRightComponentedVertex
 * @brief A vertex whose value can be represented by two complex numbers
 */
class LeftAndRightComponentedVertex {
private:
   std::pair<std::complex<double>, std::complex<double>> value;  ///< The values
public:
   LeftAndRightComponentedVertex(const std::complex<double> &left,
                                 const std::complex<double> &right)
      : value(left, right) {}

   /**
    * @fn left
    * @brief Returns the left component of the vertex.
    */
   std::complex<double> left() const
   {
      return value.first;
   }

   /**
    * @fn right
    * @brief Returns the left component of the vertex.
    */
   std::complex<double> right() const
   {
      return value.second;
   }

   /**
    * @fn isZero
    * @brief Tests whether the values are numerically significant
    */
   bool isZero() const
   {
      return (is_zero(value.first.real()) && is_zero(value.first.imag()) &&
              is_zero(value.second.real()) && is_zero(value.second.imag()));
   }
};

/**
 * @class VertexFunctionData<P...>
 * @brief Vertex data for a vertex with the particles specified by P...
 *
 * All elements in P... have to be publicly derived from Particle.
 * The data includes the type of the vertex, whether P... is in
 * canonical order or permuted as well as index bounds referring to
 * the specific particles (generation and colour indices, etc).
 * The intention is to have a program generate VertexFunctionData<>
 * specialisations that are then used by the VertexFunction<> template.
 */
template<class ...P> struct VertexFunctionData;

/**
 * @class VertexFunctionHelper<bool, P...>
 * @brief A helper template that is used by VertexFunction<P...>
 *
 * You should never have to use this class directly. It is just a
 * helper class.
 */
template<bool, class ...P> class VertexFunctionHelper;

template<class ...P> class VertexFunctionHelper<false, P...>
   : public VertexFunctionData<P...> {
private:
   typedef VertexFunctionData<P...> Base;
   typedef typename Base::particleIndexStart particleIndexStart;
   using Base::indexB;
public:
   typedef typename Base::index_bounds index_bounds;
   typedef typename index_bounds::indices_type indices_type;
   typedef typename Base::vertex_type vertex_type;
public:
   static const index_bounds &indexBounds()
   {
      return indexB;
   }

   template<unsigned int particleIndex>
   static std::vector<unsigned int> particleIndices(const indices_type &indices)
   {
      auto begin = indices.begin() + boost::mpl::at_c<particleIndexStart, particleIndex>::type::value;
      auto end = indices.begin() + boost::mpl::at_c<particleIndexStart, particleIndex+1>::type::value;
      return std::vector<unsigned int>(begin, end);
   }
};

template<class ...P> class VertexFunctionHelper<true, P...>
   : public VertexFunctionData<P...>::orig_type {
private:
   typedef typename VertexFunctionData<P...>::orig_type orig_type;
   typedef typename VertexFunctionData<P...>::particlePermutation particlePermutation;
public:
   typedef typename orig_type::index_bounds index_bounds;
   typedef typename index_bounds::indices_type indices_type;
   typedef typename orig_type::vertex_type vertex_type;
public:
   template<unsigned int particleIndex>
   static std::vector<unsigned int> particleIndices(const indices_type &indices)
   {
      return orig_type::template particleIndices<
                boost::mpl::at_c<particlePermutation, particleIndex>::type::value
                > (indices);
   }
};

/**
 * @class VertexFunction<P...>
 * @brief A template that represents a vertex with open particle indices.
 *
 * All elements in P... have to be publicly derived from Particle.
 * To obtain a conrete value, use the static member function vertex()
 * along with the desired particle indices.
 * The intention here is to have a program generate the vertex calculation
 * code for a canonically ordered P... and have c++ take care of
 * possible particle permutations.
 */
template<class ...P> class VertexFunction
   : public VertexFunctionHelper<VertexFunctionData<P...>::is_permutation, P...> {
private:
   typedef VertexFunctionHelper<VertexFunctionData<P...>::is_permutation, P...> Base;
public:
   typedef typename Base::indices_type indices_type;
   typedef typename Base::index_bounds index_bounds;
   typedef typename Base::vertex_type vertex_type;

   /**
    * @fn indexBounds
    * @brief Returns the IndexBounds<> object of the VertexFunction.
    */
   using Base::indexBounds;

   /**
    * @fn particleIndices
    * @brief Returns the subset of indices belonging to
    *        a particle at a given index.
    * @param indices The complete set of indices for all particles
    *
    * The particle indexing is in the same order as the template arguments
    * and starts at 0.
    */
   using Base::particleIndices;

   /**
    * @fn vertex
    * @brief Calculates the vertex for a given set of particle indices.
    * @param indices The particle indices
    * @param context The evaluation context
    *
    * Q is just used for SFINAE (c++)
    * This definition only kicks in for permuted P...
    * For canonical P... the definitions have to be supplied separately.
    */
   template<class Q = Base>
   static vertex_type vertex(const indices_type &indices, EvaluationContext &context)
   {
      return Q::vertex(indices, context);
   }
};

@GMuonMinus2_VertexFunctionData@
}

double @ModelName@_GMuonMinus2::calculate_amuon(@ModelName@_mass_eigenstates &model)
{
   // make copy since model is modified via call to calculate_MFe_pole()
   @ModelName@_mass_eigenstates model(model_);

#ifdef ENABLE_THREADS
@GMuonMinus2_ThreadedCalculation@
#else
@GMuonMinus2_Calculation@
#endif
}

namespace {
/**
* @defgroup LoopFunctions
* @brief The loop functions necessary for GMM2 one-loop calculations.
*
* These are OneLoopFunctionF1C(), OneLoopFunctionF2C(),
* OneLoopFunctionF1N() and OneLoopFunctionF2N()
* as specified in arXiv:1311.1775
*/

double OneLoopFunctionF1C(double x)
{
if (is_zero(x))
return 4.0;

/* error around x=1 is <= 10^-12 on an intel i7 */
double y = x - 1.0;
if (std::abs(y) < 0.21) {
return (1.0000000000000000000 -
0.60000000000000000000  * y +
0.40000000000000000000  * y * y -
0.28571428571428571429  * y * y * y +
0.21428571428571428571  * y * y * y * y -
0.16666666666666666667  * y * y * y * y * y +
0.13333333333333333333  * y * y * y * y * y * y -
0.10909090909090909091  * y * y * y * y * y * y * y +
0.090909090909090909091 * y * y * y * y * y * y * y * y -
0.076923076923076923077 * y * y * y * y * y * y * y * y * y +
0.065934065934065934066 * y * y * y * y * y * y * y * y * y * y -
0.057142857142857142857 * y * y * y * y * y * y * y * y * y * y * y +
0.050000000000000000000 * y * y * y * y * y * y * y * y * y * y * y * y -
0.044117647058823529412 * y * y * y * y * y * y * y * y * y * y * y * y * y +
0.039215686274509803922 * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
0.035087719298245614035 * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
}

return 2.0 / (y * y * y * y) * (2.0 + 3.0 * x - 6.0 * x * x + x * x * x + 6.0 * x * std::log(x));
}

double OneLoopFunctionF2C(double x)
{
/* error around x=1 is <= 10^-13 on an intel i7 */
double y = x - 1.0;
if (std::abs(y) < 0.155)
return (1.0 - 0.75 * y + 0.6 * y * y -
0.50000000000000000000 * y * y * y +
0.4285714285714285714  * y * y * y * y -
0.37500000000000000000 * y * y * y * y * y +
0.33333333333333333333 * y * y * y * y * y * y -
0.3000000000000000000  * y * y * y * y * y * y * y +
0.2727272727272727273  * y * y * y * y * y * y * y * y -
0.2500000000000000000  * y * y * y * y * y * y * y * y * y +
0.23076923076923076923 * y * y * y * y * y * y * y * y * y * y -
0.21428571428571428571 * y * y * y * y * y * y * y * y * y * y * y +
0.2000000000000000000  * y * y * y * y * y * y * y * y * y * y * y * y -
0.1875000000000000000  * y * y * y * y * y * y * y * y * y * y * y * y * y +
0.1764705882352941176  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
0.16666666666666666667 * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);

return -3.0 / (2.0 * y * y * y) * (-3.0 + 4.0 * x - x * x - 2.0 * std::log(x));
}

double OneLoopFunctionF1N(double x)
{
if (is_zero(x))
return 2.0;

/* error around x=1 is <= 10^-12 on an intel i7 */
double y = x - 1.0;
if (std::abs(y) < 0.23)
return (1.0000000000000000000 -
0.4000000000000000000  * y +
0.2000000000000000000  * y * y -
0.11428571428571428571 * y * y * y +
0.07142857142857142857 * y * y * y * y -
0.04761904761904761905 * y * y * y * y * y +
0.03333333333333333333 * y * y * y * y * y * y -
0.02424242424242424242 * y * y * y * y * y * y * y +
0.0181818181818181818  * y * y * y * y * y * y * y * y -
0.01398601398601398601 * y * y * y * y * y * y * y * y * y +
0.01098901098901098901 * y * y * y * y * y * y * y * y * y * y -
0.0087912087912087912  * y * y * y * y * y * y * y * y * y * y * y +
0.00714285714285714286 * y * y * y * y * y * y * y * y * y * y * y * y -
0.0058823529411764706  * y * y * y * y * y * y * y * y * y * y * y * y * y +
0.0049019607843137255  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
0.0041279669762641899  * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);

return 2.0 / (y * y * y * y) * (1.0 - 6.0 * x + 3.0 * x * x + 2.0 * x * x * x - 6.0 * x * x * std::log(x));
}

double OneLoopFunctionF2N(double x)
{
if (is_zero(x))
return 3.0;

/* error around x=1 is <= 10^-13 on an intel i7 */
double y = x - 1.0;
if (std::abs(y) < 0.185)
return (1.0000000000000000000 -
0.50000000000000000000 * y +
0.30000000000000000000 * y * y -
0.2000000000000000000  * y * y * y +
0.14285714285714285714 * y * y * y * y -
0.10714285714285714286 * y * y * y * y * y +
0.08333333333333333333 * y * y * y * y * y * y -
0.06666666666666666667 * y * y * y * y * y * y * y +
0.05454545454545454545 * y * y * y * y * y * y * y * y -
0.0454545454545454545  * y * y * y * y * y * y * y * y * y +
0.0384615384615384615  * y * y * y * y * y * y * y * y * y * y -
0.03296703296703296703 * y * y * y * y * y * y * y * y * y * y * y +
0.0285714285714285714  * y * y * y * y * y * y * y * y * y * y * y * y -
0.02500000000000000000 * y * y * y * y * y * y * y * y * y * y * y * y * y +
0.0220588235294117647  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
0.0196078431372549020  * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);

return -3.0 / (y * y * y) * (1.0 - x * x + 2.0 * x * std::log(x));
}

@GMuonMinus2_Definitions@

template<class PhotonEmitter, class ExchangeParticle>
double DiagramEvaluator<OneLoopDiagram<3>, PhotonEmitter, ExchangeParticle>::value(EvaluationContext &context)
{
   double res = 0.0;

   typedef VertexFunction<Photon, PhotonEmitter, typename anti<PhotonEmitter>::type> photonVertexFunction;
   typedef VertexFunction<MuonFamily, typename anti<PhotonEmitter>::type, typename anti<ExchangeParticle>::type> muonVertexFunction;

   for (auto photonVertexIndexIt = photonVertexFunction::indexBounds().begin();
        photonVertexIndexIt != photonVertexFunction::indexBounds().end();
        ++photonVertexIndexIt) {
      const auto &photonVertexIndices = *photonVertexIndexIt;
      const auto &photonVertex = photonVertexFunction::vertex(photonVertexIndices, context);
      if (photonVertex.isZero())
         continue;

      // FIXME: We assume that the photonVertex is symmetric between its left and right parts!
      double photonEmitterChargeCount = photonVertex.left().real() / muonCharge(context);

      const auto &photonEmitterIndices = photonVertexFunction::template particleIndices<2>(photonVertexIndices);

      for (auto muonVertexIndexIt = muonVertexFunction::indexBounds().begin();
           muonVertexIndexIt != muonVertexFunction::indexBounds().end();
           ++muonVertexIndexIt) {
         const auto &muonVertexIndices = *muonVertexIndexIt;
         const auto &muonFamilyIndices = muonVertexFunction::template particleIndices<0>(muonVertexIndices);
         if (MuonFamily::numberOfGenerations != 1 && muonFamilyIndices[0] != muonIndex())
            continue;

         if (photonEmitterIndices != muonVertexFunction::template particleIndices<1>(muonVertexIndices))
            continue;

         const auto &muonVertex = muonVertexFunction::vertex(muonVertexIndices, context);
         if (muonVertex.isZero())
            continue;

         const auto &exchangeIndices = muonVertexFunction::template particleIndices<2>(muonVertexIndices);

         std::complex<double> zL = muonVertex.left();
         std::complex<double> zR = muonVertex.right();

         double coeffA = std::norm(zL) + std::norm(zR);
         double coeffB = (zL * std::conj(zR) + zR * std::conj(zL)).real();

         double muonMass;
         if (MuonFamily::numberOfGenerations == 1)
            muonMass = context.mass<MuonFamily>();
         else
            muonMass = context.mass<MuonFamily>(muonIndex());

         double photonEmitterMass;
         if (PhotonEmitter::numberOfGenerations == 1)
            photonEmitterMass = context.mass<PhotonEmitter>();
         else {
            unsigned int generationIndex = photonEmitterIndices[0];
            photonEmitterMass = context.mass<PhotonEmitter>(generationIndex);
         }

         double exchangeMass;
         if (ExchangeParticle::numberOfGenerations == 1)
            exchangeMass = context.mass<ExchangeParticle>();
         else {
            unsigned int generationIndex = exchangeIndices[0];
            exchangeMass = context.mass<ExchangeParticle>(generationIndex);
         }

         double massRatioSquared = photonEmitterMass / exchangeMass;
         massRatioSquared *= massRatioSquared;

         double part1 = muonMass / 12.0 * coeffA * OneLoopFunctionF1C(massRatioSquared);

         double part2;
         if (is_zero(massRatioSquared))
            part2 = 0.0;
         else
            part2 = photonEmitterMass / 3.0 * coeffB * OneLoopFunctionF2C(massRatioSquared);

         double preFactor = muonPhysicalMass(context) / (exchangeMass * exchangeMass);
         preFactor *= photonEmitterChargeCount / (16.0 * M_PI * M_PI);

         res += preFactor * (part1 + part2);
      }
   }

   return res;
}

template<class PhotonEmitter, class ExchangeParticle>
double DiagramEvaluator<OneLoopDiagram<4>, PhotonEmitter, ExchangeParticle>::value(EvaluationContext &context)
{
   double res = 0.0;

   typedef VertexFunction<Photon, PhotonEmitter, typename anti<PhotonEmitter>::type> photonVertexFunction;
   typedef VertexFunction<MuonFamily, typename anti<PhotonEmitter>::type, typename anti<ExchangeParticle>::type> muonVertexFunction;

   for (auto photonVertexIndexIt = photonVertexFunction::indexBounds().begin();
        photonVertexIndexIt != photonVertexFunction::indexBounds().end();
        ++photonVertexIndexIt) {
      const auto &photonVertexIndices = *photonVertexIndexIt;
      const auto &photonVertex = photonVertexFunction::vertex(photonVertexIndices, context);
      if (photonVertex.isZero())
         continue;

      double photonEmitterChargeCount = photonVertex.value().real() / muonCharge(context);

      const auto &photonEmitterIndices = photonVertexFunction::template particleIndices<2>(photonVertexIndices);

      for (auto muonVertexIndexIt = muonVertexFunction::indexBounds().begin();
           muonVertexIndexIt != muonVertexFunction::indexBounds().end();
           ++muonVertexIndexIt) {
         const auto &muonVertexIndices = *muonVertexIndexIt;
         const auto &muonFamilyIndices = muonVertexFunction::template particleIndices<0>(muonVertexIndices);
         if (MuonFamily::numberOfGenerations != 1 && muonFamilyIndices[0] != muonIndex())
            continue;

         if (photonEmitterIndices != muonVertexFunction::template particleIndices<1>(muonVertexIndices))
            continue;

         const auto &muonVertex = muonVertexFunction::vertex(muonVertexIndices, context);
         if (muonVertex.isZero())
            continue;

         const auto &exchangeIndices = muonVertexFunction::template particleIndices<2>(muonVertexIndices);

         std::complex<double> zL = muonVertex.left();
         std::complex<double> zR = muonVertex.right();

         double coeffA = std::norm(zL) + std::norm(zR);
         double coeffB = (zL * std::conj(zR) + zR * std::conj(zL)).real();

         double muonMass;
         if (MuonFamily::numberOfGenerations == 1)
            muonMass = context.mass<MuonFamily>();
         else
            muonMass = context.mass<MuonFamily>(muonIndex());

         double photonEmitterMass;
         if (PhotonEmitter::numberOfGenerations == 1)
            photonEmitterMass = context.mass<PhotonEmitter>();
         else {
            unsigned int generationIndex = photonEmitterIndices[0];
            photonEmitterMass = context.mass<PhotonEmitter>(generationIndex);
         }

         double exchangeMass;
         if (ExchangeParticle::numberOfGenerations == 1)
            exchangeMass = context.mass<ExchangeParticle>();
         else {
            unsigned int generationIndex = exchangeIndices[0];
            exchangeMass = context.mass<ExchangeParticle>(generationIndex);
         }

         double massRatioSquared = exchangeMass / photonEmitterMass;
         massRatioSquared *= massRatioSquared;

         double part1 = 1.0 / 12.0 * coeffA * OneLoopFunctionF1N(massRatioSquared);
         double part2 = exchangeMass / (6.0 * muonMass) * coeffB * OneLoopFunctionF2N(massRatioSquared);

         double preFactor = muonPhysicalMass(context) * muonMass / (photonEmitterMass * photonEmitterMass);
         preFactor *= - photonEmitterChargeCount / (16.0 * M_PI * M_PI);

         res += preFactor * (part1 + part2);
      }
   }

   return res;
}
}
