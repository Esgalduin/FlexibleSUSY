// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_g_muon_minus_2.cpp
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */

#include "config.h"
#include "numerics2.hpp"

#include <array>
#include <vector>

#include "@ModelName@_g_muon_minus_2.hpp"
#include "@ModelName@_two_scale_model.hpp"

using namespace flexiblesusy;

namespace flexiblesusy
{
   namespace @ModelName@_GMuonMinus2
   {
       template<unsigned int i, class T, T v1, T ...values> struct at
       { static const T value = at<i-1, T, values...>::value; };
       
       template<class T, T v1, T ...values> struct at<0, T, v1, values...>
       { static const T value = v1; };
       
       template<unsigned int ...p> struct permutation
       {
           template<unsigned int i> struct apply
           {
               static const unsigned int value = at<i, unsigned int, p...>::value;
           };
       };
       
       template<class ...Args> struct length;
       
       template<class A1, class ...Rest> struct length<A1, Rest...>
       { static const unsigned int value = 1 + length<Rest...>::value; };
       
       template<> struct length<> { static const unsigned int value = 0; };
       
       template<int N> struct IndexBounds;
       
       template<int N> class IndexIterator
       {
           friend IndexBounds<N>;
       private:
           const IndexBounds<N> &bounds;
           std::array<int, N> indices;
           
           IndexIterator( const IndexBounds<N> &b, const int *i )
           : bounds( b ) { std::memcpy( indices.data(), i, N*sizeof(int) ); }
       public:
           const std::array<int, N> &operator*( void ) const { return indices; }
           
           IndexIterator &operator++( void )
           {
               for( int i = 0; i != N; i++ )
               {
                   indices[i]++;
                   if( indices[i] == bounds.indexEnd[i] )
                   {
                       indices[i] = bounds.indexBegin[i];
                       continue;
                   }
                   
                   return *this;
               }
               
               std::memcpy( indices.data(), bounds.indexEnd, N*sizeof(int) );
               return *this;
           }
           
           IndexIterator operator++( int )
           {
               IndexIterator it( *this );
               this->operator++();
               return it;
           }
           
           template<int M>
           friend bool operator==( const IndexIterator<M> &it1, const IndexIterator<M> &it2 );
       };
       
       template<int N>
       bool operator==( const IndexIterator<N> &it1, const IndexIterator<N> &it2 )
       { return it1.indices == it2.indices; }
       
       template<int N>
       bool operator!=( const IndexIterator<N> &it1, const IndexIterator<N> &it2 )
       { return !(it1 == it2 ); }
       
       template<int N> struct IndexBounds
       {
           int indexBegin[N];
           int indexEnd[N];
           
           using const_iterator = IndexIterator<N>;
           
           const_iterator begin( void ) const
           { return const_iterator( *this, indexBegin ); }
           
           const_iterator end( void ) const
           { return const_iterator( *this, indexEnd ); }
       };
       
       template<> struct IndexBounds<0>
       {
           std::array<int, 0> indexBegin;
           std::array<int, 0> indexEnd;
           
           using const_iterator = const std::array<int, 0> *;
           
           const_iterator begin( void ) const { return &indexBegin; }
           const_iterator end( void ) const { return &indexEnd; }
       };

       // Evaluation context struct, needed by DiagramEvaluator<>::value() further below
       struct EvaluationContext
       {
           const @ModelName@<Two_scale> &model;

           // Function templates that returns the mass of a particle
           // If P denotes a whole (SARAH) particle family, the index
           // specifies which particular particle is meant.
           template<class P> double mass( void ) const;
           template<class P> double mass( int index ) const;
       };

@GMuonMinus2_Particles@

@GMuonMinus2_Diagrams@

       // Classes that represent one specific vertex
       class SingleComponentedVertex
       {
       private:
           std::complex<double> val;
       public:
           SingleComponentedVertex( std::complex<double> v )
           : val( v ) {}
           
           std::complex<double> value( void ) const { return val; }
           bool isZero( void ) const
           { return (is_zero( val.real() ) && is_zero( val.imag() )); }
       };
       
       class LeftAndRightComponentedVertex
       {
       private:
           std::pair<std::complex<double>, std::complex<double>> value;
       public:
           LeftAndRightComponentedVertex( const std::complex<double> &left,
                                         const std::complex<double> &right )
           : value( left, right ) {}
           
           std::complex<double> left( void ) const { return value.first; }
           std::complex<double> right( void ) const { return value.second; }
           
           bool isZero( void ) const
           { return (is_zero( value.first.real() ) && is_zero( value.first.imag() ) &&
                     is_zero( value.second.real() ) && is_zero( value.second.imag() )); }
       };
       
       // Classes that represent more general vertices
       // No particle indices are specified here.
       template<class ...P> struct VertexFunctionData;
       
       template<bool, class ...P> class VertexFunctionHelper;
       
       template<class ...P> class VertexFunctionHelper<false, P...>
       : public VertexFunctionData<P...>
       {
       private:
           using Base = VertexFunctionData<P...>;
           using Base::particleIndexStart;
           using Base::indexB;
       public:
           using typename Base::indices_type;
           using typename Base::index_bounds;
           using typename Base::vertex_type;
       public:
           static const index_bounds &indexBounds( void ) { return indexB; }
           
           template<unsigned int particleIndex>
           static std::vector<int> particleIndices( const indices_type &indices )
           {
               auto begin = indices.begin() + particleIndexStart[particleIndex];
               auto end = indices.begin() + particleIndexStart[particleIndex+1];
               return std::vector<int>( begin, end );
           }
       };
       
       template<class ...P> class VertexFunctionHelper<true, P...>
       : public VertexFunctionData<P...>::orig_type
       {
       private:
           using orig_type = typename VertexFunctionData<P...>::orig_type;
           using particlePermutation = typename VertexFunctionData<P...>::particlePermutation;
       public:
           using indices_type = typename orig_type::indices_type;
           using index_bounds = typename orig_type::index_bounds;
           using vertex_type = typename orig_type::vertex_type;
       public:
           template<unsigned int particleIndex>
           static std::vector<int> particleIndices( const indices_type &indices )
           { return orig_type::template particleIndices<particlePermutation::template apply<particleIndex>::value>( indices ); }
       };
       
       template<class ...P> class VertexFunction
       : public VertexFunctionHelper<VertexFunctionData<P...>::is_permutation, P...>
       {
       private:
           using Base = VertexFunctionHelper<VertexFunctionData<P...>::is_permutation, P...>;
       public:
           using typename Base::indices_type;
           using typename Base::index_bounds;
           using typename Base::vertex_type;

           template<class Q = Base>
           static vertex_type vertex( const indices_type &indices, const EvaluationContext &context )
           { return Q::vertex( indices, context ); }
       };

@GMuonMinus2_VertexFunctions@

       // Loop functions
       static inline double OneLoopFunctionF1C( double x )
       { return 2.0/pow(1.0-x,4) * (2.0 + 3.0*x - 6.0*x*x + x*x*x + 6.0*x*log(x)); }
       static inline double OneLoopFunctionF2C( double x )
       { return 3.0/(2.0*pow(1.0-x,3)) * (-3.0 + 4.0*x - x*x - 2.0*log(x)); }
   }
}

using namespace flexiblesusy::@ModelName@_GMuonMinus2;

double @ModelName@_GMuonMinus2::calculate_amuon( const @ModelName@<Two_scale> &model )
{
#ifdef ENABLE_THREADS
@GMuonMinus2_Calculation@
#else
@GMuonMinus2_ThreadedCalculation@
#endif
}

@GMuonMinus2_Definitions@

template<class PhotonEmitter, class ExchangeParticle>
double DiagramEvaluator<OneLoopDiagram<3>, PhotonEmitter, ExchangeParticle>::value( const EvaluationContext &context )
{
    double res = 0.0;
    
    using photonVertexFunction = VertexFunction<Photon, PhotonEmitter, typename bar<PhotonEmitter>::type>;
    using muonVertexFunction = VertexFunction<MuonFamily, typename bar<PhotonEmitter>::type, typename @ModelName@_GMuonMinus2::conj<ExchangeParticle>::type>;
    
    for( auto photonVertexIndexIt = photonVertexFunction::indexBounds().begin();
        photonVertexIndexIt != photonVertexFunction::indexBounds().end();
        ++photonVertexIndexIt )
    {
        const auto &photonVertexIndices = *photonVertexIndexIt;
        const auto &photonVertex = photonVertexFunction::vertex( photonVertexIndices, context );
        if( photonVertex.isZero() )
            continue;
        
        // FIXME: We assume that the photonVertex is symmetric between its left and right parts!
        double photonEmitterChargeCount = photonVertex.left().real() / muonCharge( context );
        
        const auto &photonEmitterIndices = photonVertexFunction::template particleIndices<2>( photonVertexIndices );
        
        for( auto muonVertexIndexIt = muonVertexFunction::indexBounds().begin();
            muonVertexIndexIt != muonVertexFunction::indexBounds().end();
            ++muonVertexIndexIt )
        {
            const auto &muonVertexIndices = *muonVertexIndexIt;
            const auto &muonFamilyIndices = muonVertexFunction::template particleIndices<0>( muonVertexIndices );
            if( MuonFamily::numberOfGenerations != 1 && muonFamilyIndices[0] != muonIndex() )
                continue;
            
            if( photonEmitterIndices != muonVertexFunction::template particleIndices<1>( muonVertexIndices ) )
                continue;
            
            const auto &muonVertex = muonVertexFunction::vertex( muonVertexIndices, context );
            if( muonVertex.isZero() )
                continue;
            
            const auto &exchangeIndices = muonVertexFunction::template particleIndices<2>( muonVertexIndices );
            
            std::complex<double> zL = muonVertex.left();
            std::complex<double> zR = muonVertex.right();
            
            double coeffA = std::norm( zL ) + std::norm( zR );
            double coeffB = (zL * std::conj( zR ) + zR * std::conj( zL )).real();
            
            double muonMass;
            if( MuonFamily::numberOfGenerations == 1 )
                muonMass = context.mass<MuonFamily>();
            else
                muonMass = context.mass<MuonFamily>( muonIndex() );
            
            double photonEmitterMass;
            if( PhotonEmitter::numberOfGenerations == 1 )
                photonEmitterMass = context.mass<PhotonEmitter>();
            else
            {
                int generationIndex = photonEmitterIndices[0];
                photonEmitterMass = context.mass<PhotonEmitter>( generationIndex );
            }
            
            double exchangeMass;
            if( ExchangeParticle::numberOfGenerations == 1 )
                exchangeMass = context.mass<ExchangeParticle>();
            else
            {
                int generationIndex = exchangeIndices[0];
                exchangeMass = context.mass<ExchangeParticle>( generationIndex );
            }
            
            double massRatioSquared = photonEmitterMass / exchangeMass;
            massRatioSquared *= massRatioSquared;
            
            double part1 = muonMass / 12.0 * coeffA * OneLoopFunctionF1C( massRatioSquared );
            double part2 = photonEmitterMass / 3.0 * coeffB * OneLoopFunctionF2C( massRatioSquared );
            
            auto preFactor = muonMass / (exchangeMass * exchangeMass);
            preFactor *= photonEmitterChargeCount / (16.0 * M_PI * M_PI);
            
            res += preFactor * (part1 + part2);
        }
    }
    
    return res;
}

template<class PhotonEmitter, class ExchangeParticle>
double DiagramEvaluator<OneLoopDiagram<4>, PhotonEmitter, ExchangeParticle>::value( const EvaluationContext &context )
{
    return 0.0;
}
