
#include "@ModelName@_high_scale_constraint.hpp"
#include "@ModelName@_model.hpp"
#include "wrappers.hpp"
#include "logger.hpp"

#include <cassert>
#include <cmath>
#include <cerrno>
#include <cstring>

#define INPUTPARAMETER(p) inputPars.p
#define MODELPARAMETER(p) model->get_##p()
#define BETAPARAMETER(p) beta_functions.get_##p()
#define BETA(p) beta_##p

@ModelName@_high_scale_constraint::@ModelName@_high_scale_constraint(const @ModelName@_input_parameters& inputPars_)
   : Constraint<Two_scale>()
   , model(0)
   , inputPars(inputPars_)
{
@scaleGuess@
}

@ModelName@_high_scale_constraint::~@ModelName@_high_scale_constraint()
{
}

void @ModelName@_high_scale_constraint::apply()
{
   assert(model && "Error: @ModelName@_high_scale_constraint:"
          " model pointer must not be zero");

   update_scale();

@applyConstraint@
}

double @ModelName@_high_scale_constraint::get_scale() const
{
   return scale;
}

void @ModelName@_high_scale_constraint::set_model(Two_scale_model* model_)
{
   model = cast_model<@ModelName@>(model_);
}

void @ModelName@_high_scale_constraint::update_scale()
{
   const double currentScale = model->get_scale();
   const int old_loops = model->get_loops();
   model->set_loops(1);
   const @ModelName@_soft_parameters beta_functions(model->calc_beta());
   model->set_loops(old_loops);

@calculateScale@

   if (errno == ERANGE) {
      ERROR("Overflow error during calculation of high scale: " << strerror(errno));
   @scaleGuess@
   }
}
