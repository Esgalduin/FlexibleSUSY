// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_input_parameters.hpp"
#include "@ModelName@_observables.hpp"
#include "@ModelName@_physical.hpp"
#include "@ModelName@_spectrum_generator.hpp"
#include "@ModelName@_two_scale_model.hpp"
#include "@ModelName@_two_scale_model_slha.hpp"

#include "physical_input.hpp"
#include "spectrum_generator_settings.hpp"
#include "lowe.h"
#include "wrappers.hpp"

#include "mathlink.h"
#include "mathlink_macros.hpp"
#include "WolframLibrary.h"

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <map>
#include <sstream>
#include <thread>

#include <fcntl.h>
#include <unistd.h>

#define INPUTPARAMETER(p) input.p
#define MODELPARAMETER(p) model.get_##p()
#define PHYSICALPARAMETER(p) model.get_physical().p
#define OBSERVABLE(o) observables.o

using namespace flexiblesusy;

typedef Two_scale algorithm_type;
typedef mint Handle_id;

struct Model_data {
   Model_data();

   @ModelName@_input_parameters input;     ///< model input parameters
   Physical_input physical_input;          ///< extra non-SLHA physical input
   softsusy::QedQcd qedqcd;                ///< SLHA physical input
   Spectrum_generator_settings settings;   ///< spectrum generator settings
   double parameter_output_scale;          ///< output scale for running parameters
   @ModelName@_slha<algorithm_type> model; ///< running parameters and pole masses
};

Model_data::Model_data()
   : input()
   , physical_input()
   , qedqcd()
   , settings()
   , parameter_output_scale(0.)
   , model()
{
}

/// current handles
typedef std::map<Handle_id, Model_data> Handle_map;
Handle_map handles;

/// used handle numbers
static Handle_id used_ids = 0;

/// mutex to lock global variables
std::mutex mtx;

#define LOCK_MUTEX() mtx.lock()
#define UNLOCK_MUTEX() mtx.unlock()

/******************************************************************/

void calculate_spectrum(Model_data& data)
{
   softsusy::QedQcd qedqcd(data.qedqcd);

   try {
      qedqcd.to(qedqcd.displayPoleMZ());
   } catch (const std::string& s) {
      // put_message("FS@ModelName@CalculateSpectrum", "error", s);
      // put_error_output();
      return;
   }

   @ModelName@_spectrum_generator<algorithm_type> spectrum_generator;
   spectrum_generator.set_settings(data.settings);
   spectrum_generator.set_parameter_output_scale(data.parameter_output_scale);
   spectrum_generator.run(qedqcd, data.input);

   data.model = @ModelName@_slha<algorithm_type>(
      spectrum_generator.get_model(),
      data.settings.get(Spectrum_generator_settings::force_positive_masses) == 0.);

   const Problems<@ModelName@_info::NUMBER_OF_PARTICLES>& problems
      = spectrum_generator.get_problems();

   if (problems.have_problem()) {
      std::ostringstream msg;
      problems.print_problems(msg);
      // put_message("FS@ModelName@CalculateSpectrum", "error", msg.str());
   }

   if (problems.have_warning()) {
      std::ostringstream msg;
      problems.print_warnings(msg);
      // put_message("FS@ModelName@CalculateSpectrum", "warning", msg.str());
   }

   if (!problems.have_problem() ||
       data.settings.get(Spectrum_generator_settings::force_output)) {
      // put_spectrum(data.model);
   } else {
      // put_error_output();
   }
}

/******************************************************************/

Model_data fill(double* pars, mint npars)
{
   Model_data data;

   const mint n_settings = 17, n_sm_parameters = 0;
   const mint n_total = n_settings + n_sm_parameters;

   if (npars != n_total) {
      std::cerr << "Error in fill(): not enough arguments: " << npars
                << ".  Expected: " << n_total << std::endl;
      return data;
   }

   mint c = 0; // counter

   data.settings.set(Spectrum_generator_settings::precision, pars[c++]);
   data.settings.set(Spectrum_generator_settings::max_iterations, pars[c++]);
   data.settings.set(Spectrum_generator_settings::calculate_sm_masses, pars[c++]);
   data.settings.set(Spectrum_generator_settings::pole_mass_loop_order, pars[c++]);
   data.settings.set(Spectrum_generator_settings::ewsb_loop_order, pars[c++]);
   data.settings.set(Spectrum_generator_settings::beta_loop_order, pars[c++]);
   data.settings.set(Spectrum_generator_settings::threshold_corrections_loop_order, pars[c++]);
   data.settings.set(Spectrum_generator_settings::higgs_2loop_correction_at_as, pars[c++]);
   data.settings.set(Spectrum_generator_settings::higgs_2loop_correction_ab_as, pars[c++]);
   data.settings.set(Spectrum_generator_settings::higgs_2loop_correction_at_at, pars[c++]);
   data.settings.set(Spectrum_generator_settings::higgs_2loop_correction_atau_atau, pars[c++]);
   data.settings.set(Spectrum_generator_settings::force_output, pars[c++]);
   data.settings.set(Spectrum_generator_settings::top_2loop_corrections_qcd, pars[c++]);
   data.settings.set(Spectrum_generator_settings::beta_zero_threshold, pars[c++]);
   data.settings.set(Spectrum_generator_settings::force_positive_masses, pars[c++]);
   data.settings.set(Spectrum_generator_settings::pole_mass_scale, pars[c++]);
   data.parameter_output_scale = pars[c++];

   if (npars != c) {
      std::cerr << "Error: Bug: number of given input parameters (" << npars
                << ") does not match number of set input parameters (" << c
                << ")." << std::endl;
   }

   return data;
}

extern "C" {

/******************************************************************/

DLLEXPORT mint WolframLibrary_getVersion()
{
   return WolframLibraryVersion;
}

/******************************************************************/

DLLEXPORT int WolframLibrary_initialize(WolframLibraryData libData)
{
   return LIBRARY_NO_ERROR;
}

/******************************************************************/

DLLEXPORT int FS@ModelName@OpenHandle(
   WolframLibraryData libData, mint Argc, MArgument* Args, MArgument Res)
{
   if (Argc != 1)
      return LIBRARY_TYPE_ERROR;

   MTensor pars = MArgument_getMTensor(Args[0]);

   if (libData->MTensor_getType(pars) != MType_Real ||
       libData->MTensor_getRank(pars) != 1)
      return LIBRARY_TYPE_ERROR;

   const Model_data data = fill(libData->MTensor_getRealData(pars),
                                libData->MTensor_getDimensions(pars)[0]);

   LOCK_MUTEX();

   const Handle_id hid = used_ids++;
   handles.emplace(hid, data);

   UNLOCK_MUTEX();

   std::cout << "handle " << hid << " created" << std::endl;

   MArgument_setInteger(Res, hid);

   return LIBRARY_NO_ERROR;
}

/******************************************************************/

DLLEXPORT int FS@ModelName@CloseHandle(
   WolframLibraryData libData, mint Argc, MArgument* Args, MArgument Res)
{
   if (Argc != 1)
      return LIBRARY_TYPE_ERROR;

   const Handle_id hid = MArgument_getInteger(Args[0]);

   LOCK_MUTEX();

   const Handle_map::iterator handle = handles.find(hid);

   if (handle != handles.end()) {
      std::cout << "removing handle " << hid << std::endl;
      handles.erase(handle);
   }

   UNLOCK_MUTEX();

   return LIBRARY_NO_ERROR;
}

/******************************************************************/

DLLEXPORT int FS@ModelName@CalculateSpectrum(
   WolframLibraryData libData, mint Argc, MArgument* Args, MArgument Res)
{
   if (Argc != 1)
      return LIBRARY_TYPE_ERROR;

   const Handle_id hid = MArgument_getInteger(Args[0]);

   LOCK_MUTEX();

   const Handle_map::iterator handle = handles.find(hid);

   if (handle == handles.end()) {
      std::cout << "unknown handle: " << hid << std::endl;
      UNLOCK_MUTEX();
      return LIBRARY_FUNCTION_ERROR;
   }

   Model_data data = handle->second;

   UNLOCK_MUTEX();

   calculate_spectrum(data);
   // put spectrum here
   std::cout << "Mhh = " << data.model.get_physical().Mhh << std::endl;

   LOCK_MUTEX();
   handles[hid] = data;
   UNLOCK_MUTEX();

   return LIBRARY_NO_ERROR;
}

} // extern "C"
