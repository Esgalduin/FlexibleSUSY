// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_input_parameters.hpp"
#include "@ModelName@_observables.hpp"
#include "@ModelName@_physical.hpp"
#include "@ModelName@_spectrum_generator.hpp"
#include "@ModelName@_two_scale_model.hpp"
#include "@ModelName@_two_scale_model_slha.hpp"

#include "error.hpp"
#include "physical_input.hpp"
#include "spectrum_generator_settings.hpp"
#include "lowe.h"
#include "wrappers.hpp"

#include "mathlink.h"
#include "mathlink_macros.hpp"
#include "WolframLibrary.h"

#include <iostream>
#include <map>
#include <mutex>
#include <string>

#define INPUTPARAMETER(p) input.p
#define MODELPARAMETER(p) model.get_##p()
#define PHYSICALPARAMETER(p) model.get_physical().p
#define OBSERVABLE(o) observables.o

using namespace flexiblesusy;

typedef Two_scale algorithm_type;
typedef mint Handle_id;

namespace flexiblesusy {
class EUnknownHandle : public Error {
public:
   explicit EUnknownHandle(Handle_id hid_) : hid(hid_) {}
   virtual ~EUnknownHandle() {}
   virtual std::string what() const {
      return "Unknown handle: " + ToString(hid);
   }
   Handle_id hid;
};
}

struct Model_data {
   Model_data();

   @ModelName@_input_parameters input;     ///< model input parameters
   Physical_input physical_input;          ///< extra non-SLHA physical input
   softsusy::QedQcd qedqcd;                ///< SLHA physical input
   Spectrum_generator_settings settings;   ///< spectrum generator settings
   double parameter_output_scale;          ///< output scale for running parameters
   @ModelName@_slha<algorithm_type> model; ///< running parameters and pole masses
};

Model_data::Model_data()
   : input()
   , physical_input()
   , qedqcd()
   , settings()
   , parameter_output_scale(0.)
   , model()
{
}

/// current handles
typedef std::map<Handle_id, Model_data> Handle_map;
Handle_map handles;

/// used handle numbers
static Handle_id used_ids = 0;

/// mutex to lock global variables
std::mutex mtx;

#define LOCK_MUTEX() std::lock_guard<std::mutex> __lg(mtx)

/******************************************************************/

Handle_id get_id()
{
   LOCK_MUTEX();
   return used_ids++;
}

/******************************************************************/

Model_data find_data(Handle_id hid)
{
   LOCK_MUTEX();

   const Handle_map::iterator handle = handles.find(hid);

   if (handle == handles.end())
      throw EUnknownHandle(hid);

   return handle->second;
}

/******************************************************************/

void calculate_spectrum(Model_data& data)
{
   softsusy::QedQcd qedqcd(data.qedqcd);

   try {
      qedqcd.to(qedqcd.displayPoleMZ());
   } catch (const std::string& s) {
      // put_message("FS@ModelName@CalculateSpectrum", "error", s);
      // put_error_output();
      return;
   }

   @ModelName@_spectrum_generator<algorithm_type> spectrum_generator;
   spectrum_generator.set_settings(data.settings);
   spectrum_generator.set_parameter_output_scale(data.parameter_output_scale);
   spectrum_generator.run(qedqcd, data.input);

   data.model = @ModelName@_slha<algorithm_type>(
      spectrum_generator.get_model(),
      data.settings.get(Spectrum_generator_settings::force_positive_masses) == 0.);

   const Problems<@ModelName@_info::NUMBER_OF_PARTICLES>& problems
      = spectrum_generator.get_problems();

   if (problems.have_problem()) {
      std::ostringstream msg;
      problems.print_problems(msg);
      // put_message("FS@ModelName@CalculateSpectrum", "error", msg.str());
   }

   if (problems.have_warning()) {
      std::ostringstream msg;
      problems.print_warnings(msg);
      // put_message("FS@ModelName@CalculateSpectrum", "warning", msg.str());
   }

   if (!problems.have_problem() ||
       data.settings.get(Spectrum_generator_settings::force_output)) {
      // put_spectrum(data.model);
   } else {
      // put_error_output();
   }
}

/******************************************************************/

Model_data fill(double* pars, mint npars)
{
   Model_data data;

   const mint n_settings = 17, n_sm_parameters = 19;
   const mint n_total = n_settings + n_sm_parameters;

   if (npars != n_total) {
      std::cerr << "Error in fill(): not enough arguments: " << npars
                << ".  Expected: " << n_total << std::endl;
      return data;
   }

   mint c = 0; // counter

   data.settings.set(Spectrum_generator_settings::precision, pars[c++]);
   data.settings.set(Spectrum_generator_settings::max_iterations, pars[c++]);
   data.settings.set(Spectrum_generator_settings::calculate_sm_masses, pars[c++]);
   data.settings.set(Spectrum_generator_settings::pole_mass_loop_order, pars[c++]);
   data.settings.set(Spectrum_generator_settings::ewsb_loop_order, pars[c++]);
   data.settings.set(Spectrum_generator_settings::beta_loop_order, pars[c++]);
   data.settings.set(Spectrum_generator_settings::threshold_corrections_loop_order, pars[c++]);
   data.settings.set(Spectrum_generator_settings::higgs_2loop_correction_at_as, pars[c++]);
   data.settings.set(Spectrum_generator_settings::higgs_2loop_correction_ab_as, pars[c++]);
   data.settings.set(Spectrum_generator_settings::higgs_2loop_correction_at_at, pars[c++]);
   data.settings.set(Spectrum_generator_settings::higgs_2loop_correction_atau_atau, pars[c++]);
   data.settings.set(Spectrum_generator_settings::force_output, pars[c++]);
   data.settings.set(Spectrum_generator_settings::top_2loop_corrections_qcd, pars[c++]);
   data.settings.set(Spectrum_generator_settings::beta_zero_threshold, pars[c++]);
   data.settings.set(Spectrum_generator_settings::force_positive_masses, pars[c++]);
   data.settings.set(Spectrum_generator_settings::pole_mass_scale, pars[c++]);
   data.parameter_output_scale = pars[c++];

   data.qedqcd = softsusy::QedQcd();

   data.qedqcd.setAlpha(softsusy::ALPHA, pars[c]);
   data.qedqcd.setAlphaEmInput(pars[c++]);
   data.qedqcd.setFermiConstant(pars[c++]);
   data.qedqcd.setAlpha(softsusy::ALPHAS, pars[c]);
   data.qedqcd.setAlphaSInput(pars[c++]);
   data.qedqcd.setPoleMZ(pars[c]);
   data.qedqcd.setMu(pars[c++]);
   data.qedqcd.setMass(softsusy::mBottom, pars[c]);
   data.qedqcd.setMbMb(pars[c++]);
   data.qedqcd.setPoleMt(pars[c++]);
   data.qedqcd.setMass(softsusy::mTau, pars[c]);
   data.qedqcd.setPoleMtau(pars[c++]);
   data.qedqcd.setNeutrinoPoleMass(3, pars[c++]);
   data.qedqcd.setPoleMW(pars[c++]);
   data.qedqcd.setMass(softsusy::mElectron, pars[c]);
   data.qedqcd.setPoleMel(pars[c++]);
   data.qedqcd.setNeutrinoPoleMass(1, pars[c++]);
   data.qedqcd.setMass(softsusy::mMuon, pars[c]);
   data.qedqcd.setPoleMmuon(pars[c++]);
   data.qedqcd.setNeutrinoPoleMass(2, pars[c++]);
   data.qedqcd.setMass(softsusy::mDown, pars[c]);
   data.qedqcd.setMd2GeV(pars[c++]);
   data.qedqcd.setMass(softsusy::mUp, pars[c]);
   data.qedqcd.setMu2GeV(pars[c++]);
   data.qedqcd.setMass(softsusy::mStrange, pars[c]);
   data.qedqcd.setMs2GeV(pars[c++]);
   data.qedqcd.setMass(softsusy::mCharm, pars[c]);
   data.qedqcd.setMcMc(pars[c++]);

   data.physical_input.set(Physical_input::alpha_em_0, pars[c++]);
   data.physical_input.set(Physical_input::mh_pole, pars[c++]);

   if (npars != c) {
      std::cerr << "Error: Bug: number of given input parameters (" << npars
                << ") does not match number of set input parameters (" << c
                << ")." << std::endl;
   }

   return data;
}

extern "C" {

/******************************************************************/

DLLEXPORT mint WolframLibrary_getVersion()
{
   return WolframLibraryVersion;
}

/******************************************************************/

DLLEXPORT int WolframLibrary_initialize(WolframLibraryData libData)
{
   return LIBRARY_NO_ERROR;
}

/******************************************************************/

DLLEXPORT int FS@ModelName@OpenHandle(
   WolframLibraryData libData, mint Argc, MArgument* Args, MArgument Res)
{
   if (Argc != 1)
      return LIBRARY_TYPE_ERROR;

   MTensor pars = MArgument_getMTensor(Args[0]);

   if (libData->MTensor_getType(pars) != MType_Real ||
       libData->MTensor_getRank(pars) != 1)
      return LIBRARY_TYPE_ERROR;

   const Model_data data = fill(libData->MTensor_getRealData(pars),
                                libData->MTensor_getDimensions(pars)[0]);

   const Handle_id hid = get_id();

   {
      LOCK_MUTEX();
      handles.emplace(hid, data);
   }

   std::cout << "handle " << hid << " created" << std::endl;

   MArgument_setInteger(Res, hid);

   return LIBRARY_NO_ERROR;
}

/******************************************************************/

DLLEXPORT int FS@ModelName@CloseHandle(
   WolframLibraryData libData, mint Argc, MArgument* Args, MArgument Res)
{
   if (Argc != 1)
      return LIBRARY_TYPE_ERROR;

   const Handle_id hid = MArgument_getInteger(Args[0]);

   {
      LOCK_MUTEX();

      const Handle_map::iterator handle = handles.find(hid);

      if (handle != handles.end()) {
         std::cout << "removing handle " << hid << std::endl;
         handles.erase(handle);
      }
   }

   return LIBRARY_NO_ERROR;
}

/******************************************************************/

DLLEXPORT int FS@ModelName@CalculateSpectrum(
   WolframLibraryData libData, mint Argc, MArgument* Args, MArgument Res)
{
   if (Argc != 1)
      return LIBRARY_TYPE_ERROR;

   const Handle_id hid = MArgument_getInteger(Args[0]);

   try {
      Model_data data = find_data(hid);

      calculate_spectrum(data);
      // put spectrum here
      std::cout << "Mhh = " << data.model.get_physical().Mhh << std::endl;

      {
         LOCK_MUTEX();
         handles[hid] = data;
      }
   } catch (const flexiblesusy::Error& e) {
      std::cerr << e.what() << std::endl;
      return LIBRARY_FUNCTION_ERROR;
   }

   return LIBRARY_NO_ERROR;
}

} // extern "C"
