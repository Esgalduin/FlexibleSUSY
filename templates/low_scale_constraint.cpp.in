// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_low_scale_constraint.hpp"
#include "@ModelName@_model.hpp"
#include "wrappers.hpp"
#include "logger.hpp"
#include "ew_input.hpp"

#include <cassert>
#include <cmath>

#define INPUTPARAMETER(p) inputPars.p
#define MODELPARAMETER(p) model->get_##p()
#define BETAPARAMETER(p) beta_functions.get_##p()
#define BETA(p) beta_##p
#define SM(p) Electroweak_constants::p

@ModelName@_low_scale_constraint::@ModelName@_low_scale_constraint(const @ModelName@_input_parameters& inputPars_)
   : Constraint<Two_scale>()
   , model(0)
   , inputPars(inputPars_)
{
@scaleGuess@
}

@ModelName@_low_scale_constraint::~@ModelName@_low_scale_constraint()
{
}

void @ModelName@_low_scale_constraint::apply()
{
   assert(model && "Error: @ModelName@_low_scale_constraint:"
          " model pointer must not be zero");

   model->solve_ewsb(0);
   model->calculate_DRbar_parameters();
   update_scale();
   calculate_DRbar_gauge_couplings();
   calculate_DRbar_yukawa_couplings();

   const double MZDRbar
      = model->calculate_M@VectorZ@_DRbar_1loop(Electroweak_constants::MZ);
   const double MWDRbar
      = model->calculate_M@VectorW@_DRbar_1loop(Electroweak_constants::MW);

@applyConstraint@
}

double @ModelName@_low_scale_constraint::get_scale() const
{
   return scale;
}

void @ModelName@_low_scale_constraint::set_model(Two_scale_model* model_)
{
   model = cast_model<@ModelName@>(model_);
}

void @ModelName@_low_scale_constraint::update_scale()
{
@calculateScale@
}

void @ModelName@_low_scale_constraint::calculate_DRbar_gauge_couplings()
{
   const double MZ = Electroweak_constants::MZ;
   const double MW = Electroweak_constants::MW;
   const double MZ2 = Sqr(MZ);
   const double MW2 = Sqr(MW);
   const double cW2 = MW2/MZ2;

   const double self_energy_Z = Re(model->self_energy_@VectorZ@_heavy(MZ));
   const double self_energy_W = Re(model->self_energy_@VectorW@_heavy(MW));
   const double delta_sW2 = - cW2 * (self_energy_W / MW2 - self_energy_Z / MZ2);
   double sinThetaW2_drbar = Sqr(SM(sinThetaW)) + delta_sW2;

   if (sinThetaW2_drbar <= 1.0e-4 || sinThetaW2_drbar >= 0.99) {
#ifdef VERBOSE
      WARNING("@ModelName@_low_scale_constraint: loop corrections to"
              " sinThetaW are non-perturbative, resetting sinThetaW to"
              " the Standard Model value");
#endif
      sinThetaW2_drbar = Sqr(SM(sinThetaW));
   }
   const double sinThetaW_drbar = Sqrt(sinThetaW2_drbar);
   const double cosThetaW_drbar = Sqrt(1.0 - sinThetaW2_drbar);

   const double alpha_em = Sqr(SM(e) ) / (4. * Pi);
   const double alpha_s  = Sqr(SM(g3)) / (4. * Pi);

   const double delta_alpha_em = calculate_delta_alpha_em(alpha_em);
   const double delta_alpha_s  = calculate_delta_alpha_s(alpha_s);

   const double alpha_em_drbar = alpha_em / (1.0 - delta_alpha_em);
   const double alpha_s_drbar  = alpha_s  / (1.0 - delta_alpha_s);

   const double e_drbar  = Sqrt(4.0 * Pi * alpha_em_drbar);
   const double g3_drbar = Sqrt(4.0 * Pi * alpha_s_drbar);
   const double g1_gut_normalization = @hyperchargeCouplingInverseGutNormalization@;
   const double g2_gut_normalization = @leftCouplingInverseGutNormalization@;

   model->set_g1(e_drbar * g1_gut_normalization / cosThetaW_drbar);
   model->set_g2(e_drbar * g2_gut_normalization / sinThetaW_drbar);
   model->set_g3(g3_drbar);
}

double @ModelName@_low_scale_constraint::calculate_delta_alpha_em(double alphaEm) const
{
   const double currentScale = model->get_scale();
@calculateDeltaAlphaEm@
}

double @ModelName@_low_scale_constraint::calculate_delta_alpha_s(double alphaS) const
{
   const double currentScale = model->get_scale();
@calculateDeltaAlphaS@
}

void @ModelName@_low_scale_constraint::calculate_DRbar_yukawa_couplings()
{
   Eigen::Matrix<double,3,3> topDRbar(Eigen::Matrix<double,3,3>::Zero()),
      bottomDRbar(Eigen::Matrix<double,3,3>::Zero()),
      electronDRbar(Eigen::Matrix<double,3,3>::Zero());
   topDRbar(0,0)      = Electroweak_constants::MUP;
   topDRbar(1,1)      = Electroweak_constants::MCHARM;
   topDRbar(2,2)      = model->calculate_M@TopQuark@_DRbar_1loop(Electroweak_constants::PMTOP, 3);
   bottomDRbar(0,0)   = Electroweak_constants::MDOWN;
   bottomDRbar(1,1)   = Electroweak_constants::MSTRANGE;
   bottomDRbar(2,2)   = model->calculate_M@BottomQuark@_DRbar_1loop(Electroweak_constants::MBOTTOM, 3);
   electronDRbar(0,0) = Electroweak_constants::MELECTRON;
   electronDRbar(1,1) = Electroweak_constants::MMUON;
   electronDRbar(2,2) = model->calculate_M@Electron@_DRbar_1loop(Electroweak_constants::MTAU, 3);

@setDRbarYukawaCouplings@
}
