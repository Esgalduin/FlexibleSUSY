// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_input_parameters.hpp"
#include "@ModelName@_physical.hpp"
#include "@ModelName@_spectrum_generator.hpp"
#include "@ModelName@_two_scale_model.hpp"
#include "@ModelName@_two_scale_model_slha.hpp"

#include "physical_input.hpp"
#include "spectrum_generator_settings.hpp"
#include "lowe.h"

#include "mathlink.h"
#include "mathlink_macros.hpp"

#include <sstream>

using namespace flexiblesusy;
typedef Two_scale algorithm_type;

@ModelName@_input_parameters input; ///< model input parameters
Physical_input physical_input;      ///< extra non-SLHA physical input
softsusy::QedQcd qedqcd;            ///< SLHA physical input
Spectrum_generator_settings spectrum_generator_settings;
double parameter_output_scale = 0.; ///< output scale for running parameters

extern "C" {

/******************************************************************/

void put_error_output()
{
   MLPutFunction(stdlink, "List", 0);
   MLEndPacket(stdlink);
}

/******************************************************************/

void put_error_message(const std::string& function_name,
                       const std::string& message_tag,
                       const std::string& message_str)
{
   MLPutFunction(stdlink, "CompoundExpression", 2);
   MLPutFunction(stdlink, "Message", 2);
   MLPutFunction(stdlink, "MessageName", 2);
   MLPutSymbol(stdlink, function_name.c_str());
   MLPutString(stdlink, message_tag.c_str());
   MLPutString(stdlink, message_str.c_str());
}

/******************************************************************/

void put_spectrum(const @ModelName@_slha<algorithm_type>& model)
{
   put_error_output();
}

/******************************************************************/

int FSGetSMInputParameters@ModelName@()
{
   MLPutFunction(stdlink, "List", 19);

   MLPutRuleToReal(stdlink, qedqcd.displayAlphaEmInput(), "alphaEmMZ");
   MLPutRuleToReal(stdlink, qedqcd.displayFermiConstant(), "GF");
   MLPutRuleToReal(stdlink, qedqcd.displayAlphaSInput(), "alphaSMZ");
   MLPutRuleToReal(stdlink, qedqcd.displayPoleMZ(), "MZ");
   MLPutRuleToReal(stdlink, qedqcd.displayMbMb(), "mbmb");
   MLPutRuleToReal(stdlink, qedqcd.displayPoleMt(), "Mt");
   MLPutRuleToReal(stdlink, qedqcd.displayPoleMtau(), "Mtau");
   MLPutRuleToReal(stdlink, qedqcd.displayNeutrinoPoleMass(3), "Mv3");
   MLPutRuleToReal(stdlink, qedqcd.displayPoleMW(), "MW");
   MLPutRuleToReal(stdlink, qedqcd.displayPoleMel(), "Me");
   MLPutRuleToReal(stdlink, qedqcd.displayNeutrinoPoleMass(1), "Mv1");
   MLPutRuleToReal(stdlink, qedqcd.displayPoleMmuon(), "Mm");
   MLPutRuleToReal(stdlink, qedqcd.displayNeutrinoPoleMass(2), "Mv2");
   MLPutRuleToReal(stdlink, qedqcd.displayMd2GeV(), "md2GeV");
   MLPutRuleToReal(stdlink, qedqcd.displayMu2GeV(), "mu2GeV");
   MLPutRuleToReal(stdlink, qedqcd.displayMs2GeV(), "ms2GeV");
   MLPutRuleToReal(stdlink, qedqcd.displayMcMc(), "mcmc");

   MLPutRuleToReal(stdlink, physical_input.get(Physical_input::alpha_em_0), "alphaEm0");
   MLPutRuleToReal(stdlink, physical_input.get(Physical_input::mh_pole), "Mh");

   // put CKM and PMNS matrices

   MLEndPacket(stdlink);
}

/******************************************************************/

int FSSetSMInputParameters@ModelName@(
    double alphaEmMZ,
    double GF,
    double alphaSMZ,
    double MZ,
    double mbmb,
    double Mt,
    double Mtau,
    double Mv3,
    double MW,
    double Me,
    double Mv1,
    double Mm,
    double Mv2,
    double md2GeV,
    double mu2GeV,
    double ms2GeV,
    double mcmc,
    double alphaEm0,
    double Mh
)
{
   qedqcd = softsusy::QedQcd();

   qedqcd.setAlpha(softsusy::ALPHA, alphaEmMZ);
   qedqcd.setAlphaEmInput(alphaEmMZ);
   qedqcd.setFermiConstant(GF);
   qedqcd.setAlpha(softsusy::ALPHAS, alphaSMZ);
   qedqcd.setAlphaSInput(alphaSMZ);
   qedqcd.setPoleMZ(MZ);
   qedqcd.setMu(MZ);
   softsusy::MZ = MZ;
   qedqcd.setMass(softsusy::mBottom, mbmb);
   qedqcd.setMbMb(mbmb);
   qedqcd.setPoleMt(Mt);
   qedqcd.setMass(softsusy::mTau, Mtau);
   qedqcd.setPoleMtau(Mtau);
   qedqcd.setNeutrinoPoleMass(3, Mv3);
   qedqcd.setPoleMW(MW);
   qedqcd.setMass(softsusy::mElectron, Me);
   qedqcd.setPoleMel(Me);
   qedqcd.setNeutrinoPoleMass(1, Mv1);
   qedqcd.setMass(softsusy::mMuon, Mm);
   qedqcd.setPoleMmuon(Mm);
   qedqcd.setNeutrinoPoleMass(2, Mv2);
   qedqcd.setMass(softsusy::mDown, md2GeV);
   qedqcd.setMd2GeV(md2GeV);
   qedqcd.setMass(softsusy::mUp, mu2GeV);
   qedqcd.setMu2GeV(mu2GeV);
   qedqcd.setMass(softsusy::mStrange, ms2GeV);
   qedqcd.setMs2GeV(ms2GeV);
   qedqcd.setMass(softsusy::mCharm, mcmc);
   qedqcd.setMcMc(mcmc);

   physical_input.set(Physical_input::alpha_em_0, alphaEm0);
   physical_input.set(Physical_input::mh_pole, Mh);

   // read CKM and PMNS matrices

   return 0;
}

/******************************************************************/

void FSCalculateSpectrum@ModelName@()
{
   try {
      qedqcd.to(qedqcd.displayPoleMZ());
   } catch (const std::string& s) {
      put_error_message("FSCalculateSpectrum@ModelName@", "error", s);
      put_error_output();
      return;
   }

   @ModelName@_spectrum_generator<algorithm_type> spectrum_generator;
   spectrum_generator.set_settings(spectrum_generator_settings);
   spectrum_generator.set_parameter_output_scale(parameter_output_scale);
   spectrum_generator.run(qedqcd, input);

   // convert to SLHA
   const @ModelName@_slha<algorithm_type> model(
      spectrum_generator.get_model(),
      spectrum_generator_settings.get(Spectrum_generator_settings::force_positive_masses) == 0.);

   const Problems<@ModelName@_info::NUMBER_OF_PARTICLES>& problems
      = spectrum_generator.get_problems();

   // output
   if (!problems.have_problem() ||
       spectrum_generator_settings.get(Spectrum_generator_settings::force_output)) {
      put_spectrum(model);
   } else {
      std::ostringstream msg;
      problems.print_problems(msg);
      put_error_message("FSCalculateSpectrum@ModelName@", "error", msg.str());
      put_error_output();
   }
}

/******************************************************************/

} // extern "C"

int main(int argc, char *argv[])
{
   return MLMain(argc, argv);
}
