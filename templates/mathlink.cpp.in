// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_input_parameters.hpp"
#include "@ModelName@_observables.hpp"
#include "@ModelName@_physical.hpp"
#include "@ModelName@_spectrum_generator.hpp"
#include "@ModelName@_two_scale_model.hpp"
#include "@ModelName@_two_scale_model_slha.hpp"

#include "physical_input.hpp"
#include "spectrum_generator_settings.hpp"
#include "lowe.h"
#include "wrappers.hpp"

#include "mathlink.h"
#include "mathlink_macros.hpp"

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <thread>

#include <fcntl.h>
#include <unistd.h>

#define INPUTPARAMETER(p) input.p
#define MODELPARAMETER(p) model.get_##p()
#define PHYSICALPARAMETER(p) model.get_physical().p
#define OBSERVABLE(o) observables.o

using namespace flexiblesusy;
typedef Two_scale algorithm_type;

@ModelName@_input_parameters input; ///< model input parameters
Physical_input physical_input;      ///< extra non-SLHA physical input
softsusy::QedQcd qedqcd;            ///< SLHA physical input
Spectrum_generator_settings spectrum_generator_settings;
double parameter_output_scale = 0.; ///< output scale for running parameters
@ModelName@_slha<algorithm_type> model; ///< running parameters and pole masses

int stdout_orig;                    ///< original file descriptor for stdout
int stderr_orig;                    ///< original file descriptor for stderr
int stdout_pipe[2];                 ///< pipe where stdout/stderr is redirected to
std::thread stdout_thread;          ///< thread redirecting stdout

/******************************************************************/

void redirect_stdout(int pfd[2])
{
   const int fd = pfd[0];
   unsigned char* buf = NULL;
   std::size_t size = 0;
   const std::size_t unit = 10240;
   std::size_t len = 0, n;

   do {
      if (size - len < 128)
         buf = static_cast<unsigned char*>(std::realloc(buf, size += unit));
      len += n = read(fd, buf + len, size - len);
   } while (n > 0);

   if (len) {
      // send each line in a separate message
      std::istringstream istr(std::string(reinterpret_cast<const char*>(buf), len));
      std::string line;
      while (std::getline(istr, line)) {
         MLPutFunction(stdlink, "EvaluatePacket", 1);
         MLPutFunction(stdlink, "FSmsg", 1);
         MLPutString(stdlink, line.c_str());
         MLEndPacket(stdlink);
         MLNextPacket(stdlink);
         MLNewPacket(stdlink);
      }
   }

   free(buf);
}

/******************************************************************/

void begin_redirect()
{
   try {
      if (pipe(stdout_pipe) != -1)
         stdout_thread = std::thread(redirect_stdout, stdout_pipe);
   } catch (const std::exception& e) {
      std::cerr << "Error: could not create thread for redirection"
         " of stdout.  Redirecting stdout to stderr." << std::endl;
      stdout_pipe[1] = 2;
   }

   dup2(stdout_pipe[1], 1);
   dup2(stdout_pipe[1], 2);
   close(stdout_pipe[1]);
}

/******************************************************************/

void end_redirect()
{
   fflush(stdout);
   dup2(stdout_orig, 1);
   dup2(stderr_orig, 2);

   if (stdout_thread.joinable())
      stdout_thread.join();
}

/******************************************************************/

void put_error_output()
{
   MLPutSymbol(stdlink, "$Failed");
}

/******************************************************************/

void put_message(const std::string& function_name,
                 const std::string& message_tag,
                 const std::string& message_str)
{
   MLPutFunction(stdlink, "CompoundExpression", 2);
   MLPutFunction(stdlink, "Message", 2);
   MLPutFunction(stdlink, "MessageName", 2);
   MLPutSymbol(stdlink, function_name.c_str());
   MLPutString(stdlink, message_tag.c_str());
   MLPutString(stdlink, message_str.c_str());
}

/******************************************************************/

void put_spectrum(const @ModelName@_slha<algorithm_type>& model)
{
   MLPutFunction(stdlink, "List", @numberOfSpectrumEntries@);

@putSpectrum@

   MLEndPacket(stdlink);
}

/******************************************************************/

void put_observables(const @ModelName@_observables& observables)
{
   MLPutFunction(stdlink, "List", @numberOfObservables@);

@putObservables@

   MLEndPacket(stdlink);
}

extern "C" {

/******************************************************************/

void FS@ModelName@GetSettings()
{
   MLPutFunction(stdlink, "List", 17);

   MLPutRuleTo(stdlink, spectrum_generator_settings.get(Spectrum_generator_settings::precision), "precisionGoal");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::max_iterations), "maxIterations");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::calculate_sm_masses), "calculateStandardModelMasses");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::pole_mass_loop_order), "poleMassLoopOrder");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::ewsb_loop_order), "ewsbLoopOrder");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::beta_loop_order), "betaFunctionLoopOrder");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::threshold_corrections_loop_order), "thresholdCorrectionsLoopOrder");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::higgs_2loop_correction_at_as), "higgs2loopCorrectionAtAs");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::higgs_2loop_correction_ab_as), "higgs2loopCorrectionAbAs");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::higgs_2loop_correction_at_at), "higgs2loopCorrectionAtAt");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::higgs_2loop_correction_atau_atau), "higgs2loopCorrectionAtauAtau");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::force_output), "forceOutput");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::top_2loop_corrections_qcd), "top2loopCorrectionsQCD");
   MLPutRuleTo(stdlink, spectrum_generator_settings.get(Spectrum_generator_settings::beta_zero_threshold), "betaZeroThreshold");
   MLPutRuleTo(stdlink, (int)spectrum_generator_settings.get(Spectrum_generator_settings::force_positive_masses), "forcePositiveMasses");
   MLPutRuleTo(stdlink, spectrum_generator_settings.get(Spectrum_generator_settings::pole_mass_scale), "poleMassScale");
   MLPutRuleTo(stdlink, parameter_output_scale, "parameterOutputScale");

   MLEndPacket(stdlink);
}

/******************************************************************/

int FS@ModelName@SetSettings(
   double precision_goal_,
   int max_iterations_,
   int calculate_sm_masses_,
   int pole_mass_loop_order_,
   int ewsb_loop_order_,
   int beta_loop_order_,
   int threshold_corrections_loop_order_,
   int higgs_2loop_correction_at_as_,
   int higgs_2loop_correction_ab_as_,
   int higgs_2loop_correction_at_at_,
   int higgs_2loop_correction_atau_atau_,
   int force_output_,
   int top_2loop_corrections_qcd_,
   double beta_zero_threshold_,
   int force_positive_masses_,
   double pole_mass_scale_,
   double parameter_output_scale_)
{
   if (pole_mass_loop_order_ != ewsb_loop_order_) {
      put_message(
         "FS@ModelName@SetSettings", "warning",
         "poleMassLoopOrder (" + ToString(pole_mass_loop_order_) + ") != "
         + "ewsbLoopOrder (" + ToString(ewsb_loop_order_) + ")!"
         " Loop corrections might be taken into account in an inconsistent"
         " way!");
   }

   spectrum_generator_settings.set(Spectrum_generator_settings::precision, precision_goal_);
   spectrum_generator_settings.set(Spectrum_generator_settings::max_iterations, max_iterations_);
   spectrum_generator_settings.set(Spectrum_generator_settings::calculate_sm_masses, calculate_sm_masses_);
   spectrum_generator_settings.set(Spectrum_generator_settings::pole_mass_loop_order, pole_mass_loop_order_);
   spectrum_generator_settings.set(Spectrum_generator_settings::ewsb_loop_order, ewsb_loop_order_);
   spectrum_generator_settings.set(Spectrum_generator_settings::beta_loop_order, beta_loop_order_);
   spectrum_generator_settings.set(Spectrum_generator_settings::threshold_corrections_loop_order, threshold_corrections_loop_order_);
   spectrum_generator_settings.set(Spectrum_generator_settings::higgs_2loop_correction_at_as, higgs_2loop_correction_at_as_);
   spectrum_generator_settings.set(Spectrum_generator_settings::higgs_2loop_correction_ab_as, higgs_2loop_correction_ab_as_);
   spectrum_generator_settings.set(Spectrum_generator_settings::higgs_2loop_correction_at_at, higgs_2loop_correction_at_at_);
   spectrum_generator_settings.set(Spectrum_generator_settings::higgs_2loop_correction_atau_atau, higgs_2loop_correction_atau_atau_);
   spectrum_generator_settings.set(Spectrum_generator_settings::force_output, force_output_);
   spectrum_generator_settings.set(Spectrum_generator_settings::top_2loop_corrections_qcd, top_2loop_corrections_qcd_);
   spectrum_generator_settings.set(Spectrum_generator_settings::beta_zero_threshold, beta_zero_threshold_);
   spectrum_generator_settings.set(Spectrum_generator_settings::force_positive_masses, force_positive_masses_);
   spectrum_generator_settings.set(Spectrum_generator_settings::pole_mass_scale, pole_mass_scale_);
   parameter_output_scale = parameter_output_scale_;

   return 0;
}

/******************************************************************/

void FS@ModelName@GetSMInputParameters()
{
   MLPutFunction(stdlink, "List", 19);

   MLPutRuleTo(stdlink, qedqcd.displayAlphaEmInput(), "alphaEmMZ");
   MLPutRuleTo(stdlink, qedqcd.displayFermiConstant(), "GF");
   MLPutRuleTo(stdlink, qedqcd.displayAlphaSInput(), "alphaSMZ");
   MLPutRuleTo(stdlink, qedqcd.displayPoleMZ(), "MZ");
   MLPutRuleTo(stdlink, qedqcd.displayMbMb(), "mbmb");
   MLPutRuleTo(stdlink, qedqcd.displayPoleMt(), "Mt");
   MLPutRuleTo(stdlink, qedqcd.displayPoleMtau(), "Mtau");
   MLPutRuleTo(stdlink, qedqcd.displayNeutrinoPoleMass(3), "Mv3");
   MLPutRuleTo(stdlink, qedqcd.displayPoleMW(), "MW");
   MLPutRuleTo(stdlink, qedqcd.displayPoleMel(), "Me");
   MLPutRuleTo(stdlink, qedqcd.displayNeutrinoPoleMass(1), "Mv1");
   MLPutRuleTo(stdlink, qedqcd.displayPoleMmuon(), "Mm");
   MLPutRuleTo(stdlink, qedqcd.displayNeutrinoPoleMass(2), "Mv2");
   MLPutRuleTo(stdlink, qedqcd.displayMd2GeV(), "md2GeV");
   MLPutRuleTo(stdlink, qedqcd.displayMu2GeV(), "mu2GeV");
   MLPutRuleTo(stdlink, qedqcd.displayMs2GeV(), "ms2GeV");
   MLPutRuleTo(stdlink, qedqcd.displayMcMc(), "mcmc");

   MLPutRuleTo(stdlink, physical_input.get(Physical_input::alpha_em_0), "alphaEm0");
   MLPutRuleTo(stdlink, physical_input.get(Physical_input::mh_pole), "Mh");

   // put CKM and PMNS matrices

   MLEndPacket(stdlink);
}

/******************************************************************/

int FS@ModelName@SetSMInputParameters(
   double alphaEmMZ,
   double GF,
   double alphaSMZ,
   double MZ,
   double mbmb,
   double Mt,
   double Mtau,
   double Mv3,
   double MW,
   double Me,
   double Mv1,
   double Mm,
   double Mv2,
   double md2GeV,
   double mu2GeV,
   double ms2GeV,
   double mcmc,
   double alphaEm0,
   double Mh)
{
   qedqcd = softsusy::QedQcd();

   qedqcd.setAlpha(softsusy::ALPHA, alphaEmMZ);
   qedqcd.setAlphaEmInput(alphaEmMZ);
   qedqcd.setFermiConstant(GF);
   qedqcd.setAlpha(softsusy::ALPHAS, alphaSMZ);
   qedqcd.setAlphaSInput(alphaSMZ);
   qedqcd.setPoleMZ(MZ);
   qedqcd.setMu(MZ);
   softsusy::MZ = MZ;
   qedqcd.setMass(softsusy::mBottom, mbmb);
   qedqcd.setMbMb(mbmb);
   qedqcd.setPoleMt(Mt);
   qedqcd.setMass(softsusy::mTau, Mtau);
   qedqcd.setPoleMtau(Mtau);
   qedqcd.setNeutrinoPoleMass(3, Mv3);
   qedqcd.setPoleMW(MW);
   qedqcd.setMass(softsusy::mElectron, Me);
   qedqcd.setPoleMel(Me);
   qedqcd.setNeutrinoPoleMass(1, Mv1);
   qedqcd.setMass(softsusy::mMuon, Mm);
   qedqcd.setPoleMmuon(Mm);
   qedqcd.setNeutrinoPoleMass(2, Mv2);
   qedqcd.setMass(softsusy::mDown, md2GeV);
   qedqcd.setMd2GeV(md2GeV);
   qedqcd.setMass(softsusy::mUp, mu2GeV);
   qedqcd.setMu2GeV(mu2GeV);
   qedqcd.setMass(softsusy::mStrange, ms2GeV);
   qedqcd.setMs2GeV(ms2GeV);
   qedqcd.setMass(softsusy::mCharm, mcmc);
   qedqcd.setMcMc(mcmc);

   physical_input.set(Physical_input::alpha_em_0, alphaEm0);
   physical_input.set(Physical_input::mh_pole, Mh);

   // read CKM and PMNS matrices

   return 0;
}

/******************************************************************/

void FS@ModelName@GetInputParameters()
{
   MLPutFunction(stdlink, "List", @numberOfInputParameters@);

@putInputParameters@

   MLEndPacket(stdlink);
}

/******************************************************************/

int FS@ModelName@SetInputParameters(
@setInputParameterArgumentCTypes@)
{
@setInputParameters@

   return 0;
}

/******************************************************************/

void FS@ModelName@CalculateSpectrum()
{
   begin_redirect();

   softsusy::QedQcd qedqcd_(qedqcd);

   try {
      qedqcd_.to(qedqcd_.displayPoleMZ());
   } catch (const std::string& s) {
      put_message("FS@ModelName@CalculateSpectrum", "error", s);
      put_error_output();
      return;
   }

   @ModelName@_spectrum_generator<algorithm_type> spectrum_generator;
   spectrum_generator.set_settings(spectrum_generator_settings);
   spectrum_generator.set_parameter_output_scale(parameter_output_scale);
   spectrum_generator.run(qedqcd_, input);

   model = @ModelName@_slha<algorithm_type>(
      spectrum_generator.get_model(),
      spectrum_generator_settings.get(Spectrum_generator_settings::force_positive_masses) == 0.);

   const Problems<@ModelName@_info::NUMBER_OF_PARTICLES>& problems
      = spectrum_generator.get_problems();

   end_redirect();

   if (problems.have_problem()) {
      std::ostringstream msg;
      problems.print_problems(msg);
      put_message("FS@ModelName@CalculateSpectrum", "error", msg.str());
   }

   if (problems.have_warning()) {
      std::ostringstream msg;
      problems.print_warnings(msg);
      put_message("FS@ModelName@CalculateSpectrum", "warning", msg.str());
   }

   if (!problems.have_problem() ||
       spectrum_generator_settings.get(Spectrum_generator_settings::force_output)) {
      put_spectrum(model);
   } else {
      put_error_output();
   }
}

/******************************************************************/

void FS@ModelName@CalculateObservables()
{
   if (model.get_scale() == 0.) {
      put_message(
         "FS@ModelName@CalculateObservables", "warning",
         "Renormalization scale is 0.  Did you run "
         "FS@ModelName@CalculateSpectrum[]?");
   }

   try {
      begin_redirect();

      @ModelName@_observables observables(
         calculate_observables(model, qedqcd, physical_input));

      end_redirect();

      put_observables(observables);
   } catch (const flexiblesusy::Error& e) {
      put_message("FS@ModelName@CalculateObservables", "error", e.what());
      put_error_output();
   }
}

/******************************************************************/

} // extern "C"

int main(int argc, char *argv[])
{
   int fd;

   do fd = open("/dev/null", O_WRONLY); while (fd <= 2);
   close(fd);

   stdout_orig = dup(1);
   stderr_orig = dup(2);

   return MLMain(argc, argv);
}
