:Evaluate: BeginPackage["FlexibleSUSY`@ModelName@`"]
:Evaluate: EndPackage[]

:Evaluate: {alphaEmMZ, GF, alphaSMZ, MZ, mbmb,  Mt, Mtau,
       Mv3, MW, Me, Mv1, Mm, Mv2, md2GeV, mu2GeV, ms2GeV,
       mcmc, alphaEm0, Mh, CKM, PMNS}

:Evaluate: { precisionGoal, maxIterations,
      calculateStandardModelMasses, poleMassLoopOrder, ewsbLoopOrder,
      betaFunctionLoopOrder, thresholdCorrectionsLoopOrder,
      higgs2loopCorrectionAtAs, higgs2loopCorrectionAbAs,
      higgs2loopCorrectionAtAt, higgs2loopCorrectionAtauAtau,
      forceOutput, top2loopCorrectionsQCD, betaZeroThreshold,
      forcePositiveMasses, poleMassScale, parameterOutputScale }

:Evaluate: FS@ModelName@GetSMInputParameters::usage = "Returns the Standard Model parameters for the @ModelName@ model.";
:Evaluate: FS@ModelName@SetSMInputParameters::usage = "Sets the Standard Model parameters for the @ModelName@ model.";

:Evaluate: FS@ModelName@GetSettings::usage = "Returns the settings for the @ModelName@ model spectrum generator.";
:Evaluate: FS@ModelName@SetSettings::usage = "Sets the settings for the @ModelName@ model spectrum generator.";

:Evaluate: FS@ModelName@GetInputParameters::usage = "Returns the current set of input parameters of the @ModelName@.";

:Evaluate: FS@ModelName@CalculateSpectrum::usage = "Calculates the pole mass spectrum, given the input parameters set via FS@ModelName@SetInputParameters[].";
:Evaluate: FS@ModelName@CalculateSpectrum::error = "`1`";
:Evaluate: FS@ModelName@CalculateSpectrum::warning = "`1`";

:Evaluate: Begin["FlexibleSUSY`@ModelName@`Private`"]

:Begin:
:Function: FS@ModelName@GetSettings
:Pattern: FS@ModelName@GetSettings[]
:Arguments: {}
:ArgumentTypes: {}
:ReturnType: Manual
:End:

:Begin:
:Function: FS@ModelName@SetSettings
:Pattern: FS@ModelName@SetSettings[OptionsPattern[]]
:Arguments: {
      OptionValue[precisionGoal],
      OptionValue[maxIterations],
      OptionValue[calculateStandardModelMasses],
      OptionValue[poleMassLoopOrder],
      OptionValue[ewsbLoopOrder],
      OptionValue[betaFunctionLoopOrder],
      OptionValue[thresholdCorrectionsLoopOrder],
      OptionValue[higgs2loopCorrectionAtAs],
      OptionValue[higgs2loopCorrectionAbAs],
      OptionValue[higgs2loopCorrectionAtAt],
      OptionValue[higgs2loopCorrectionAtauAtau],
      OptionValue[forceOutput],
      OptionValue[top2loopCorrectionsQCD],
      OptionValue[betaZeroThreshold],
      OptionValue[forcePositiveMasses],
      OptionValue[poleMassScale],
      OptionValue[parameterOutputScale] }
:ArgumentTypes: {
   Real, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer,
   Integer, Integer, Integer, Real, Integer, Real, Real }
:ReturnType: Integer
:End:

:Evaluate: Options[FS@ModelName@SetSettings] = {
      precisionGoal -> 1.*^-4,           (* FlexibleSUSY[0] *)
      maxIterations -> 0,                (* FlexibleSUSY[1] *)
      calculateStandardModelMasses -> 0, (* FlexibleSUSY[3] *)
      poleMassLoopOrder -> 2,            (* FlexibleSUSY[4] *)
      ewsbLoopOrder -> 2,                (* FlexibleSUSY[5] *)
      betaFunctionLoopOrder -> 2,        (* FlexibleSUSY[6] *)
      thresholdCorrectionsLoopOrder -> 2,(* FlexibleSUSY[7] *)
      higgs2loopCorrectionAtAs -> 1,     (* FlexibleSUSY[8] *)
      higgs2loopCorrectionAbAs -> 1,     (* FlexibleSUSY[9] *)
      higgs2loopCorrectionAtAt -> 1,     (* FlexibleSUSY[10] *)
      higgs2loopCorrectionAtauAtau -> 1, (* FlexibleSUSY[11] *)
      forceOutput -> 0,                  (* FlexibleSUSY[12] *)
      top2loopCorrectionsQCD -> 1,       (* FlexibleSUSY[13] *)
      betaZeroThreshold -> 1.*^-11,      (* FlexibleSUSY[14] *)
      forcePositiveMasses -> 0,          (* FlexibleSUSY[16] *)
      poleMassScale -> 0,                (* FlexibleSUSY[17] *)
      parameterOutputScale -> 0 }

:Begin:
:Function: FS@ModelName@GetSMInputParameters
:Pattern: FS@ModelName@GetSMInputParameters[]
:Arguments: {}
:ArgumentTypes: {}
:ReturnType: Manual
:End:

:Begin:
:Function: FS@ModelName@SetSMInputParameters
:Pattern: FS@ModelName@SetSMInputParameters[OptionsPattern[]]
:Arguments: {
    OptionValue[alphaEmMZ],
    OptionValue[GF],
    OptionValue[alphaSMZ],
    OptionValue[MZ],
    OptionValue[mbmb],
    OptionValue[Mt],
    OptionValue[Mtau],
    OptionValue[Mv3],
    OptionValue[MW],
    OptionValue[Me],
    OptionValue[Mv1],
    OptionValue[Mm],
    OptionValue[Mv2],
    OptionValue[md2GeV],
    OptionValue[mu2GeV],
    OptionValue[ms2GeV],
    OptionValue[mcmc],
    OptionValue[alphaEm0],
    OptionValue[Mh],
    OptionValue[CKM],
    OptionValue[PMNS] }
:ArgumentTypes: {
   Real, Real, Real, Real, Real, Real, Real, Real, Real, Real,
   Real, Real, Real, Real, Real, Real, Real, Real, Real, Manual }
:ReturnType: Integer
:End:

:Evaluate: Options[FS@ModelName@SetSMInputParameters] = {
    alphaEmMZ -> 1/127.916, (* SMINPUTS[1] *)
    GF -> 1.16637*^-5,      (* SMINPUTS[2] *)
    alphaSMZ -> 0.1184,     (* SMINPUTS[3] *)
    MZ -> 91.1876,          (* SMINPUTS[4] *)
    mbmb -> 4.18,           (* SMINPUTS[5] *)
    Mt -> 173.34,           (* SMINPUTS[6] *)
    Mtau -> 1.777,          (* SMINPUTS[7] *)
    Mv3 -> 0,               (* SMINPUTS[8] *)
    MW -> 80.385,           (* SMINPUTS[9] *)
    Me -> 0.000510998902,   (* SMINPUTS[11] *)
    Mv1 -> 0,               (* SMINPUTS[12] *)
    Mm -> 0.1056583715,     (* SMINPUTS[13] *)
    Mv2 -> 0,               (* SMINPUTS[14] *)
    md2GeV -> 0.00475,      (* SMINPUTS[21] *)
    mu2GeV -> 0.0024,       (* SMINPUTS[22] *)
    ms2GeV -> 0.104,        (* SMINPUTS[23] *)
    mcmc -> 1.27,           (* SMINPUTS[24] *)
    alphaEm0 -> 1/137.035999074,
    Mh -> 125.09,
    CKM -> IdentityMatrix[3],
    PMNS -> IdentityMatrix[3] }

:Begin:
:Function: FS@ModelName@GetInputParameters
:Pattern: FS@ModelName@GetInputParameters[]
:Arguments: {}
:ArgumentTypes: {}
:ReturnType: Manual
:End:

:Begin:
:Function: FS@ModelName@CalculateSpectrum
:Pattern: FS@ModelName@CalculateSpectrum[]
:Arguments: {}
:ArgumentTypes: {}
:ReturnType: Manual
:End:

:Evaluate: End[]
