// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_model.hpp"
#include "wrappers.hpp"
#include "logger.hpp"
#include "error.hpp"
#include "gsl_utils.hpp"

#include <cmath>
#include <iostream>

#define CLASSNAME @ModelName@

#define CALC_DRBAR_PARS(model) model->calculate_DRbar_parameters()

#define PHYSICAL(parameter) physical.parameter
#define INPUT(parameter) model->get_input().parameter

@ModelName@::@ModelName@(const @ModelName@_input_parameters& input_)
   : Two_scale_model()
   , @ModelName@_soft_parameters()
   , number_of_ewsb_iterations(100)
   , number_of_mass_iterations(20)
   , ewsb_loop_order(0)
   , throw_on_tachyon(false)
   , throw_on_ewsb_fail(false)
   , ewsb_iteration_precision(1.0e-5)
   , mass_iteration_precision(1.0e-5)
   , physical()
   , input(input_)
@physicalMassesInit@
@mixingMatricesInit@
@phasesInit@
{
}

@ModelName@::~@ModelName@()
{
}

void @ModelName@::set_number_of_ewsb_iterations(std::size_t iterations)
{
   number_of_ewsb_iterations = iterations;
}

void @ModelName@::set_number_of_mass_iterations(std::size_t iterations)
{
   number_of_mass_iterations = iterations;
}

void @ModelName@::set_ewsb_loop_order(unsigned loop_order)
{
   ewsb_loop_order = loop_order;
}

void @ModelName@::set_ewsb_iteration_precision(double precision)
{
   ewsb_iteration_precision = precision;
}

void @ModelName@::set_mass_iteration_precision(double precision)
{
   mass_iteration_precision = precision;
}

unsigned @ModelName@::get_ewsb_loop_order() const
{
   return ewsb_loop_order;
}

double @ModelName@::get_ewsb_iteration_precision() const
{
   return ewsb_iteration_precision;
}

const @ModelName@_physical& @ModelName@::get_physical() const
{
   return physical;
}

const @ModelName@_input_parameters& @ModelName@::get_input() const
{
   return input;
}

int tadpole_equations(const gsl_vector* x, void* params, gsl_vector* f)
{
   if (contains_nan(x, @numberOfEWSBEquations@)) {
      for (std::size_t i = 0; i < @numberOfEWSBEquations@; ++i)
         gsl_vector_set(f, i, std::numeric_limits<double>::max());
      return 1;
   }

   @ModelName@* model = static_cast<@ModelName@*>(params);

   double tadpole[@numberOfEWSBEquations@];

@calculateTreeLevelTadpoles@
@calculateOneLoopTadpoles@

   for (std::size_t i = 0; i < @numberOfEWSBEquations@; ++i)
      gsl_vector_set(f, i, tadpole[i]);

   return GSL_SUCCESS;
}

int @ModelName@::solve_ewsb()
{
   const gsl_multiroot_fsolver_type* solvers[] =
      {gsl_multiroot_fsolver_hybrid, gsl_multiroot_fsolver_hybrids};

   double x_init[@numberOfEWSBEquations@];
   ewsb_initial_guess(x_init);

#ifdef VERBOSE
   std::cout << "Solving EWSB equations ...\n"
      "\tInitial guess: x_init =";
   for (std::size_t i = 0; i < @numberOfEWSBEquations@; ++i)
      std::cout << " " << x_init[i];
   std::cout << '\n';
#endif

   int status;
   for (std::size_t i = 0; i < sizeof(solvers)/sizeof(*solvers); ++i) {
      VERBOSE_MSG("\tStarting EWSB iteration using solver " << i);
      status = solve_ewsb_with(solvers[i], x_init);
      if (status == GSL_SUCCESS) {
         VERBOSE_MSG("\tSolver " << i << " finished successfully!");
         break;
      }
#ifdef VERBOSE
      else {
         WARNING("\tSolver " << i << " could not find a solution!"
                 " (requested precision: " << ewsb_iteration_precision << ")");
      }
#endif
   }

   if (status != GSL_SUCCESS) {
      if (throw_on_ewsb_fail) {
         throw NoEWSBError(this, ewsb_iteration_precision);
      }
#ifdef VERBOSE
      else {
         WARNING("\tCould not find a solution to the EWSB equations!"
                 " (requested precision: " << ewsb_iteration_precision << ")");
      }
#endif
   }

   return status;
}

int @ModelName@::solve_ewsb(unsigned loop_order)
{
   const unsigned old_loop_order = ewsb_loop_order;
   set_ewsb_loop_order(loop_order);
   const int error_code = solve_ewsb();
   set_ewsb_loop_order(old_loop_order);
   return error_code;
}

void @ModelName@::ewsb_initial_guess(double* x_init)
{
@initialGuess@
}

int @ModelName@::solve_ewsb_with(const gsl_multiroot_fsolver_type* solver,
                                  const double* x_init)
{
   gsl_multiroot_fsolver* s = gsl_multiroot_fsolver_alloc(solver, @numberOfEWSBEquations@);
   int status;
   std::size_t iter = 0;
   gsl_multiroot_function f = {&tadpole_equations, @numberOfEWSBEquations@, this};
   gsl_vector* x = gsl_vector_alloc(@numberOfEWSBEquations@);

   for (std::size_t i = 0; i < @numberOfEWSBEquations@; ++i)
      gsl_vector_set(x, i, x_init[i]);

   gsl_multiroot_fsolver_set(s, &f, x);

#ifdef VERBOSE
   print_state(iter, s);
#endif

   do {
      iter++;
      status = gsl_multiroot_fsolver_iterate(s);

#ifdef VERBOSE
      print_state(iter, s);
#endif

      if (status)   // check if solver is stuck
         break;

      status =
         gsl_multiroot_test_residual(s->f, ewsb_iteration_precision);
   } while (status == GSL_CONTINUE && iter < number_of_ewsb_iterations);

#ifdef VERBOSE
   printf("\tEWSB status = %s\n", gsl_strerror(status));
#endif

   gsl_multiroot_fsolver_free(s);
   gsl_vector_free(x);

   return status;
}

void @ModelName@::print_state(std::size_t iter, gsl_multiroot_fsolver* s) const
{
   std::cout << "\tIteration " << iter << ": x =";
   for (std::size_t i = 0; i < @numberOfEWSBEquations@; ++i)
      std::cout << " " << gsl_vector_get(s->x, i);
   std::cout << ", f(x) =";
   for (std::size_t i = 0; i < @numberOfEWSBEquations@; ++i)
      std::cout << " " << gsl_vector_get(s->f, i);
   std::cout << '\n';
}

void @ModelName@::print(std::ostream& ostr) const
{
   ostr << "========================================\n"
           "@ModelName@\n"
           "========================================\n";
   @ModelName@_soft_parameters::print(ostr);
   ostr << "----------------------------------------\n"
           "tree-level DRbar masses:\n"
           "----------------------------------------\n";
@printMasses@
   ostr << "----------------------------------------\n"
           "tree-level DRbar mixing matrices:\n"
           "----------------------------------------\n";
@printMixingMatrices@
   physical.print(ostr);
}

double @ModelName@::A0(double m) const
{
   return a0(m, get_scale());
}

double @ModelName@::B0(double p, double m1, double m2) const
{
   return b0(p, m1, m2, get_scale());
}

double @ModelName@::B1(double p, double m1, double m2) const
{
   return -b1(p, m1, m2, get_scale());
}

double @ModelName@::B00(double p, double m1, double m2) const
{
   return b22(p, m1, m2, get_scale());
}

double @ModelName@::B22(double p, double m1, double m2) const
{
   return b22bar(p, m1, m2, get_scale());
}

double @ModelName@::H0(double p, double m1, double m2) const
{
   return hfn(p, m1, m2, get_scale());
}

double @ModelName@::F0(double p, double m1, double m2) const
{
   return ffn(p, m1, m2, get_scale());
}

double @ModelName@::G0(double p, double m1, double m2) const
{
   return gfn(p, m1, m2, get_scale());
}

void @ModelName@::calculate_DRbar_parameters()
{
@calculateAllMasses@
}

void @ModelName@::calculate_1loop_masses()
{
   calculate_DRbar_parameters();

@callAllLoopMassFunctions@
}

void @ModelName@::calculate_spectrum()
{
   throw_on_tachyon = true;
   throw_on_ewsb_fail = true;

   // tree-level parameters
   solve_ewsb(0);
   calculate_DRbar_parameters();

   // one-loop level parameters
   solve_ewsb(1);
   calculate_1loop_masses();

   throw_on_tachyon = false;
   throw_on_ewsb_fail = false;
}

void @ModelName@::clear()
{
   @ModelName@_soft_parameters::clear();

@clearOutputParameters@
   physical.clear();
}

std::string @ModelName@::name() const
{
   return "@ModelName@";
}

int @ModelName@::run_to(double scale, double eps)
{
   return @ModelName@_soft_parameters::run_to(scale, eps);
}

@massCalculationFunctions@

@tadpoleEqFunctions@

@selfEnergyFunctions@

@loopMassesFunctions@

@runningDRbarMassesFunctions@

@dependenceNumFunctions@
