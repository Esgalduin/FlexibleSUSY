// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_mu_to_egamma.cpp
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */

#include "@ModelName@_mu_to_egamma.hpp"
#include "@ModelName@_mass_eigenstates.hpp"

#include "@ModelName@_cxx_diagrams.hpp"

#define INPUTPARAMETER(p) context.model.get_input().p
#define MODELPARAMETER(p) context.model.get_##p()
#define DERIVEDPARAMETER(p) context.model.p()
#define PHASE(p) context.model.get_##p()

using namespace flexiblesusy;
using namespace cxx_diagrams;

namespace {
static constexpr double oneOver16PiSquared = 0.0063325739776461107152;

/**
 * @class MuEGammaVertexCorrectionSF
 * @brief A template that calculate contributions to the mu to e gamma
 *        of a given particle in a one loop diagram specified
 *        by a photon emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment,
 *              the photon emitter and the exchange particle
 *              in a one-loop diagram where the photon emitter
 *              is a scalar and the exchange particle a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template<class EDMField1, class EDMField2, class PhotonEmitter, class ExchangeParticle>
struct EDMVertexCorrectionSF {
   static double value(
         const typename field_indices<EDMField1>::type& indices_in,
         const typename field_indices<EDMField1>::type& indices_out,
                       EvaluationContext& context);
};

/**
* @class EDMVertexCorrectionFS
* @brief A template that calculate contributions to the EDM
*        of a given particle in a one loop diagram specified
*        by a photon emitter and an exchange particle.
* @tparam Args Specifies in order the field of which to
*              calculate the electric dipole moment,
*              the photon emitter and the exchange particle
*              in a one-loop diagram where the photon emitter
*              is a fermion and the exchange particle a scalar.
*
* This template evaluates the contribution to the electric
* dipole moment of a one loop diagram with fields given by
* \a Args.
*/
#include <iostream>

template<class EDMField1, class EDMField2, class PhotonEmitter, class ExchangeParticle>
struct EDMVertexCorrectionFS {
   static double value(
         const typename field_indices<EDMField1>::type& indices_in,
         const typename field_indices<EDMField1>::type& indices_out,
                       EvaluationContext& context);
};
} // anonymous namespace

namespace flexiblesusy {
namespace @ModelName@_mu_to_egamma {
@MuEGamma_InterfaceDefinitions@
}
} // namespace flexiblesusy

namespace {
/**
* @defgroup LoopFunctions Loop functions
* @brief The loop functions necessary for the Fe_I -> Fe_J gamma one-loop calculations.
*
* These are OneLoopFunctionA(), OneLoopFunctionB()
* as specified in arXiv:0808.1819
*/

// function from eq. 15 of hep-ph/9510309 
double OneLoopFunctionA(double r)
{
   if (is_zero(1.0-r)) {
      return 1.5;
   } else if (is_zero(r)) {
      return 2.0;
   }
   else {
      return (2.0 - 9.0*r + 18.0*r*r - 11.0*r*r*r + 6.0*r*r*r*std::log(r))/pow(1.0-r,4);
   }
}

double OneLoopFunctionB(double r)
{
   if (is_zero(1.0-r)) {
      return 1.0/12.0;
   }
   else {
      (1.0 - 6.0*r + 3.0*r*r + 2.0*r*r*r - 6.0*r*r*std::log(r))/6.0/pow(1.0-r,4);
   }
}

double OneLoopFunctionC(double r)
{
   if (is_zero(1.0-r)) {
      return 1.0/3.0;
   } else if (is_zero(r)) {
      return 1.0;
   }
   else {
      (1.0 - r*r + 2.0*r*std::log(r))/pow(1.0-r,3);
   }
}

double OneLoopFunctionD(double r)
{
   if (is_zero(1.0-r)) {
      return -9.0/2.0;
   }
   else {
      (16.0 - 45.0*r + 36.0*r*r - 7.0*r*r*r + 6.0*(2.0-3.0*r)*std::log(r))/pow(1.0-r,4);
   }
}

double OneLoopFunctionE(double r)
{
   if (is_zero(1.0-r)) {
      return 1.0/12.0;
   } else if (is_zero(r)) {
      return 1.0/3.0;
   }
   else {
      (2.0 + 3.0*r - 6.0*r*r + r*r*r + 6.0*r*std::log(r))/6.0/pow(1.0-r,4);
   }
}

double OneLoopFunctionF(double r)
{
   if (is_zero(1.0-r)) {
      return 2.0/3.0;
   }
   else {
      (-3.0 + 4.0*r - r*r - 2.0*std::log(r))/pow(1.0-r,3);
   }
}

// emit photon from the internal scalar line
template<class EDMField1, class EDMField2, class PhotonEmitter, class ExchangeField>
double EDMVertexCorrectionFS<
EDMField1, EDMField2, PhotonEmitter, ExchangeField
>::value(
      const typename field_indices<EDMField1>::type& indices_in, 
      const typename field_indices<EDMField1>::type& indices_out, 
      EvaluationContext& context)
{
   double res = 0.0;

   using FermionVertexOut = Vertex<
                         typename EDMField2::lorentz_conjugate,
                         ExchangeField,
                         PhotonEmitter
                         >;
   using FermionVertexIn = Vertex<
                         EDMField1,
                         typename ExchangeField::lorentz_conjugate,
                         typename PhotonEmitter::lorentz_conjugate
                         >;

   constexpr auto indexBoundsOut = FermionVertexOut::index_bounds;
   constexpr auto indexBoundsIn = FermionVertexIn::index_bounds;

   // loop over all possible particle "generations" attached to both vertices
   for (const auto& indexIn: indexBoundsIn) {
      for (const auto& indexOut: indexBoundsOut) {

         // cycle if generations of external particles are different then requested   
         const auto edmFieldIndicesIn = FermionVertexIn::template fieldIndices<0>(indexIn);
         const auto edmFieldIndicesOut = FermionVertexOut::template fieldIndices<0>(indexOut);
         if (edmFieldIndicesIn != indices_in || edmFieldIndicesOut != indices_out)
            continue;

         // match internal particles in two vertices
         const auto photonEmitterIndicesIn = FermionVertexIn::template fieldIndices<2>(indexIn);
         const auto exchangeFieldIndicesIn = FermionVertexIn::template fieldIndices<1>(indexIn);
         const auto photonEmitterIndicesOut = FermionVertexOut::template fieldIndices<2>(indexOut);
         const auto exchangeFieldIndicesOut = FermionVertexOut::template fieldIndices<1>(indexOut);
         if (exchangeFieldIndicesIn != exchangeFieldIndicesOut || photonEmitterIndicesIn != photonEmitterIndicesOut)
            continue;

         const auto vertexIn = FermionVertexIn::evaluate(indexIn, context);
         const auto vertexOut = FermionVertexOut::evaluate(indexOut, context);

         const auto photonEmitterMass = context.mass<PhotonEmitter>(photonEmitterIndicesIn);
         const auto exchangeFieldMass = context.mass<ExchangeField>(exchangeFieldIndicesIn);
         const auto x = pow(exchangeFieldMass/photonEmitterMass, 2);
         const auto leptonMass = context.mass<EDMField1>(edmFieldIndicesIn);

         const double photonEmitterCharge =
            PhotonEmitter::electric_charge * unit_charge(context);

         constexpr double numericFactor = oneOver16PiSquared/2.0;
         const double couplingFactor = (vertexOut.left() * vertexIn.left()).real() * OneLoopFunctionB(x) + (vertexOut.left()* vertexIn.right()).real()* exchangeFieldMass/leptonMass *OneLoopFunctionC(x);
         std::cout << (vertexOut.left() * vertexIn.left()).real() << std::endl; 
         const double massFactor = pow(photonEmitterMass,-2);

         const double contribution = numericFactor * massFactor * couplingFactor ;

         res += contribution;
      }
   }

   return res;
}

// emit photon from the internal fermion line
template<class EDMField1, class EDMField2, class PhotonEmitter, class ExchangeField>
double EDMVertexCorrectionSF<
EDMField1, EDMField2, PhotonEmitter, ExchangeField
>::value(const typename field_indices<EDMField1>::type& indices_in, 
      const typename field_indices<EDMField1>::type& indices_out,
      EvaluationContext& context)
{
   double res = 0.0;

   using FermionVertex = Vertex<
                         typename EDMField1::lorentz_conjugate,
                         ExchangeField,
                         PhotonEmitter
                         >;

   constexpr auto indexBounds = FermionVertex::index_bounds;

   for (const auto& index: indexBounds) {
      const auto edmFieldIndices = FermionVertex::template fieldIndices<0>(index);

      //if (indices == std::array<int, 1> {2} || indices == std::array<int, 1> {1})
      //   continue;

      const auto photonEmitterIndices = FermionVertex::template fieldIndices<2>(index);
      const auto exchangeFieldIndices = FermionVertex::template fieldIndices<1>(index);
      const auto vertex = FermionVertex::evaluate(index, context);

      const auto photonEmitterMass = context.mass<PhotonEmitter>(photonEmitterIndices);
      const auto exchangeFieldMass = context.mass<ExchangeField>(exchangeFieldIndices);

      const double photonEmitterCharge =
         PhotonEmitter::electric_charge * unit_charge(context);

      constexpr double numericFactor = oneOver16PiSquared;
      const double massFactor = exchangeFieldMass/(photonEmitterMass * photonEmitterMass);
      const double couplingFactor = 1; //(std::conj(vertex.right()) * vertex.left()).imag();

      const double massRatioSquared = Sqr(exchangeFieldMass / photonEmitterMass);
      const double loopFactor = photonEmitterCharge * OneLoopFunctionB(massRatioSquared);
      const double contribution = numericFactor * massFactor * couplingFactor * loopFactor;

      res += 0*contribution;
   }

   return res;
}

} // anonymous namespace
