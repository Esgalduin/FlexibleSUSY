// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_model.hpp"
#include "@ModelName@_input_parameters.hpp"
#include "@ModelName@_high_scale_constraint.hpp"
#include "@ModelName@_susy_scale_constraint.hpp"
#include "@ModelName@_low_scale_constraint.hpp"
#include "@ModelName@_convergence_tester.hpp"
#include "@ModelName@_initial_guesser.hpp"
#include "@ModelName@_utilities.hpp"

#include "two_scale_running_precision.hpp"
#include "two_scale_solver.hpp"
#include "coupling_monitor.hpp"
#include "error.hpp"
#include "ew_input.hpp"

#include <iostream>
#include <vector>

using namespace std;

class @ModelName@_runner {
public:
   @ModelName@_runner()
      : model(), high_scale(0.), susy_scale(0.), low_scale(0.) {}
   ~@ModelName@_runner() {}

   double get_high_scale() const { return high_scale; }
   double get_susy_scale() const { return susy_scale; }
   double get_low_scale()  const { return low_scale;  }
   const @ModelName@& get_model() const { return model; }

   unsigned run(const @ModelName@_input_parameters& input) {
      @ModelName@_high_scale_constraint high_scale_constraint(input);
      @ModelName@_susy_scale_constraint susy_scale_constraint(input);
      @ModelName@_low_scale_constraint  low_scale_constraint(input);

      std::vector<Constraint<Two_scale>*> upward_constraints;
      upward_constraints.push_back(&low_scale_constraint);
      upward_constraints.push_back(&high_scale_constraint);

      std::vector<Constraint<Two_scale>*> downward_constraints;
      downward_constraints.push_back(&high_scale_constraint);
      downward_constraints.push_back(&susy_scale_constraint);
      downward_constraints.push_back(&low_scale_constraint);

      model.set_input(input);

      @ModelName@_convergence_tester convergence_tester(&model, 1.0e-5);
      @ModelName@_initial_guesser initial_guesser(&model, input,
                                                  low_scale_constraint,
                                                  susy_scale_constraint,
                                                  high_scale_constraint);
      Two_scale_increasing_precision precision(10.0, 1.0e-5);

      RGFlow<Two_scale> solver;
      solver.set_convergence_tester(&convergence_tester);
      solver.set_running_precision(&precision);
      solver.set_initial_guesser(&initial_guesser);
      solver.add_model(&model, upward_constraints, downward_constraints);

      unsigned error_code = 0;
      high_scale = susy_scale = low_scale = 0.;

      try {
         solver.solve();
         high_scale = high_scale_constraint.get_scale();
         susy_scale = susy_scale_constraint.get_scale();
         low_scale  = low_scale_constraint.get_scale();
         model.run_to(susy_scale);
         model.calculate_spectrum();
         model.run_to(low_scale);
      } catch (Error& error) {
         cout << "Error: " << error.what() << endl;
         error_code = 1;
      } catch (std::string& str) {
         cout << "Error: " << str << endl;
         error_code = 2;
      } catch (const char* str) {
         cout << "Error: " << str << endl;
         error_code = 2;
      }

      return error_code;
   }

   void write_running_couplings(const std::string& filename = "@ModelName@_rge_running.dat") const {
      @ModelName@ tmp_model(model);
      tmp_model.run_to(low_scale);

      @ModelName@_parameter_getter parameter_getter;
      Coupling_monitor<@ModelName@, @ModelName@_parameter_getter>
         coupling_monitor(tmp_model, parameter_getter);

      coupling_monitor.run(low_scale, high_scale, 100, true);
      coupling_monitor.write_to_file(filename);
   }

   void write_spectrum(const std::string& filename = "@ModelName@_spectrum.dat") const {
      @ModelName@_spectrum_plotter plotter;
      plotter.extract_spectrum(model);
      plotter.write_to_file(filename);
   }

private:
   @ModelName@ model;
   double high_scale, susy_scale, low_scale;
};

int main()
{
   @ModelName@_runner runner;
   @ModelName@_input_parameters input;

   unsigned error_code = runner.run(input);

   if (error_code == 0) {
      runner.get_model().print(std::cout);
      // runner.write_running_couplings();
      // runner.write_spectrum();
   }

   return 0;
}
