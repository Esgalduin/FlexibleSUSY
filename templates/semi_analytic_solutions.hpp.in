// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_semi_analytic_solutions.hpp
 * @brief contains class for computing the semi-analytic solutions
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ (git commit: @FlexibleSUSYGitCommit@) and SARAH @SARAHVersion@ .
 */

#ifndef @ModelName@_SEMI_ANALYTIC_SOLUTIONS_H
#define @ModelName@_SEMI_ANALYTIC_SOLUTIONS_H

#include "@ModelName@_soft_parameters.hpp"

#include <Eigen/Core>
#include <Eigen/SVD>

#include <map>
#include <vector>

namespace flexiblesusy {

class @ModelName@_soft_parameters;

/**
 * @class @ModelName@_semi_analytic_solutions
 * @brief class with routines for computing the semi-analytic solutions
 */
class @ModelName@_semi_analytic_solutions {
public:
   @ModelName@_semi_analytic_solutions();
   @ModelName@_semi_analytic_solutions(const @ModelName@_semi_analytic_solutions&) = default;
   @ModelName@_semi_analytic_solutions(@ModelName@_semi_analytic_solutions&&) = default;
   ~@ModelName@_semi_analytic_solutions() = default;
   @ModelName@_semi_analytic_solutions& operator=(const @ModelName@_semi_analytic_solutions&) = default;
   @ModelName@_semi_analytic_solutions& operator=(@ModelName@_semi_analytic_solutions&&) = default;

   double get_input_scale() const { return input_scale; }
   double get_output_scale() const { return output_scale; }

   void set_input_scale(double s) { input_scale = s; }
   void set_output_scale(double s) { output_scale = s; }

@boundaryValueGetters@
@boundaryValueSetters@
@coefficientGetters@
   void calculate_coefficients(const @ModelName@_soft_parameters&);
   void set_semi_analytic_solutions(@ModelName@_soft_parameters&);

private:
   struct Boundary_values {
@boundaryValueStructDefs@
   };

   struct Model_data {
      Boundary_values boundary_values{};
      @ModelName@_soft_parameters model{};
      std::vector<int> basis_sets{};
   };

   using Data_vector_t = std::vector<const Model_data*>;

   double input_scale{0.};  ///< scale at which boundary conditions hold
   double output_scale{0.}; ///< scale at which coefficients are calculated
   std::array<Model_data,@numberOfTrialPoints@> trial_data{};

   // semi-analytic solution coefficients
@semiAnalyticSolutionsDefs@
   // boundary values to use when setting model parameters
@boundaryValuesDefs@

   void initialize_trial_values();
   void calculate_trial_data(const @ModelName@_soft_parameters&);
   void set_to_boundary_values(@ModelName@_soft_parameters&, const Boundary_values&) const;
   @ModelName@_soft_parameters run_to_output_scale(
      const @ModelName@_soft_parameters&, const Boundary_values&) const;
   std::map<int,Data_vector_t> create_datasets() const;

   template <class MatrixType, int BasisSize, class BasisEvaluator>
   Eigen::JacobiSVD<MatrixType> create_solver(
      const Data_vector_t&, const BasisEvaluator&) const;

@calculateCoefficientsPrototypes@
};

template <class MatrixType, int BasisSize, class BasisEvaluator>
Eigen::JacobiSVD<MatrixType> @ModelName@_semi_analytic_solutions::create_solver(
   const @ModelName@_semi_analytic_solutions::Data_vector_t& data, const BasisEvaluator& ev) const
{
   const std::size_t n = data.size();
   MatrixType lhs(n, BasisSize);
   for (std::size_t i = 0; i < n; ++i) {
      lhs.row(i) = ev(data[i]->boundary_values);
   }
   return Eigen::JacobiSVD<MatrixType>(
      lhs, Eigen::ComputeThinU | Eigen::ComputeThinV);
}

} // namespace flexiblesusy

#endif
