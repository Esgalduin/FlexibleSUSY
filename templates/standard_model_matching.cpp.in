// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_standard_model_matching.hpp"
#include "wrappers.hpp"
#include "two_scale_matching.hpp"
#include "two_loop_corrections.hpp"
#include "standard_model.hpp"
#include "@ModelName@_mass_eigenstates.hpp"
#include "@ModelName@_info.hpp"
#include "config.h"
#include <cmath>

using namespace flexiblesusy::standard_model;

namespace flexiblesusy {
namespace @ModelName@_standard_model_matching {

#define MODELPARAMETER(p) model.get_##p()
#define SMPARAMETER(p) sm.get_##p()
#define INPUTPARAMETER(p) model.get_input().p

namespace {

template <class T>
class RAII_set_loop_order {
public:
   RAII_set_loop_order(T& model_, unsigned loop_order_) noexcept
      : model(model_), loop_order(loop_order_)
   {
      model_pole_mass_order = model.get_pole_mass_loop_order();
      model_ewsb_order = model.get_ewsb_loop_order();
      tlc = model.get_two_loop_corrections();

      // set top quark QCD corrections to given loop order
      Two_loop_corrections tlc_new = tlc;
      tlc_new.top_qcd = loop_order_ ? loop_order_ - 1 : 0;

      model.set_pole_mass_loop_order(loop_order);
      model.set_ewsb_loop_order(loop_order);
      model.set_two_loop_corrections(tlc_new);
   }

   ~RAII_set_loop_order() {
      model.set_pole_mass_loop_order(model_pole_mass_order);
      model.set_ewsb_loop_order(model_ewsb_order);
      model.set_two_loop_corrections(tlc);
      model.calculate_DRbar_masses();
      model.solve_ewsb();
   }
private:
   T& model;
   Two_loop_corrections tlc;       ///< 2-loop corrections
   unsigned loop_order;            ///< temporary loop order
   unsigned model_pole_mass_order; ///< old model pole mass loop order
   unsigned model_ewsb_order;      ///< old model EWSB loop order
};

template <typename T>
constexpr RAII_set_loop_order<T> make_raii_set_loop_order(T& model, unsigned loop_order)
{
   return RAII_set_loop_order<T>(model, loop_order);
}

Standard_model calculate_SM_tree_level(const Standard_model& sm, const @ModelName@_mass_eigenstates& model_0l, unsigned idx)
{
   auto sm_0l = sm;
   sm_0l.set_Lambdax(Sqr(model_0l.get_M@HiggsBoson(idx)@/sm.get_v()));
   sm_0l.solve_ewsb_tree_level();
   sm_0l.calculate_DRbar_masses();

   return sm_0l;
}

@ModelName@_mass_eigenstates calculate_@ModelName@_tree_level(
   const @ModelName@_mass_eigenstates& model,
   Standard_model eft)
{
   auto model_0l = model;
   model_0l.get_problems().clear();
   model_0l.set_pole_mass_loop_order(0);
   model_0l.set_ewsb_loop_order(0);
   model_0l.solve_ewsb_tree_level();
   model_0l.calculate_DRbar_parameters();

   match_low_to_high_scale_model_tree_level(model_0l, eft);

   return model_0l;
}

/**
 * Calculates squared Higgs pole mass in the SM,
 * \f$(M_h^{\text{SM}})^2\f$.
 *
 * @param sm Standard Model parameters
 * @param sm_0l tree-level SM parameters
 *
 * @return squared Higgs pole mass in the SM
 */
double calculate_Mh2_pole(const Standard_model& sm, const Standard_model& sm_0l)
{
   const double p = sm_0l.get_Mhh();
   const double self_energy = Re(sm_0l.self_energy_hh(p));
   const double tadpole = Re(sm_0l.tadpole_hh() / sm.get_v());
   const double mh2_tree = Sqr(sm.get_Mhh());
   const double Mh2_pole = mh2_tree - self_energy + tadpole;

   return Mh2_pole;
}

/**
 * Calculates tadpoles over vevs (at given fixed loop order)
 *
 * @param model model parameters
 * @param loop_order loop order
 *
 * @return tadpole at loop order
 */
@ModelName@_mass_eigenstates::EWSB_vector_t calculate_tadpole_over_vevs(@ModelName@_mass_eigenstates model, unsigned loop_order)
{
   model.set_ewsb_loop_order(loop_order);
   const auto tadpole_lo = model.tadpole_equations_over_vevs(); // nL

   model.set_ewsb_loop_order(loop_order - 1);
   const auto tadpole_lom1 = model.tadpole_equations_over_vevs(); // (n-1)L

   return (tadpole_lo - tadpole_lom1).eval();
}

/**
 * Calculates squared Higgs pole mass in the @ModelName@,
 * \f$(M_h^{\text{@ModelName@}})^2\f$.
 *
 * @param model @ModelName@ parameters
 * @param model_0l tree-level @ModelName@ parameters
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 *
 * @return squared Higgs pole mass in the @ModelName@
 */
double calculate_Mh2_pole(@ModelName@_mass_eigenstates model, const @ModelName@_mass_eigenstates& model_0l, unsigned idx)
{
   // solve at tree-level to obtain plain tree-level mass matrix
   model.solve_ewsb_tree_level();
   model.calculate_DRbar_masses();
   const auto mh2_tree = model.get_mass_matrix_@HiggsBoson@();

   // calculate 1L self-energy using tree-level parameters
   const double p = model_0l.get_M@HiggsBoson(idx)@;
   const auto self_energy = Re(model_0l.self_energy_hh(p));

   // calculate 1L tadpoles using tree-level parameters
   const auto tadpole = calculate_tadpole_over_vevs(model_0l, 1);

   double Mh2_pole = 0.;

@calculateMHiggsPoleOneMomentumIteration@

   return Mh2_pole;
}

/**
 * Calculates \f$\lambda(Q)\f$ at the current loop level from the
 * lightest CP-even Higgs boson mass of the @ModelName@ by requiring
 * that the Higgs pole masses are equal in both models.
 *
 * @param sm Standard Model
 * @param model @ModelName@ parameters
 * @param model_0l tree-level @ModelName@ parameters
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 */
void match_high_to_low_scale_model_impl(
   Standard_model& sm, @ModelName@_mass_eigenstates& model, const @ModelName@_mass_eigenstates& model_0l, unsigned idx)
{
   model.calculate_DRbar_masses();
   model.solve_ewsb();

   sm.calculate_DRbar_masses();
   sm.solve_ewsb();

   const double mh2_sm = Sqr(sm.get_Mhh());
   const double Mh2_sm = calculate_Mh2_pole(sm, calculate_SM_tree_level(sm, model_0l, idx));
   const double Mh2_bsm = calculate_Mh2_pole(model, model_0l, idx);

   sm.set_Lambdax((Mh2_bsm - Mh2_sm + mh2_sm)/Sqr(sm.get_v()));
}

double calculate_delta_alpha_em(double alpha_em, const @ModelName@_mass_eigenstates& model)
{
   const double currentScale = model.get_scale();
   double delta_alpha_em = 0.;

@alphaEM1Lmatching@

   return delta_alpha_em;
}

double calculate_delta_alpha_s(double alpha_s, const @ModelName@_mass_eigenstates& model)
{
   const double currentScale = model.get_scale();
   double delta_alpha_s = 0.;

@alphaS1Lmatching@

   return delta_alpha_s;
}

Eigen::Matrix<double,3,3> calculate_MFu_DRbar_tree_level(const Standard_model& sm)
{
   Eigen::Matrix<double,3,3> upQuarksDRbar = ZEROMATRIX(3,3);
   upQuarksDRbar.diagonal() = sm.get_MFu();

   return upQuarksDRbar;
}

Eigen::Matrix<double,3,3> calculate_MFd_DRbar_tree_level(const Standard_model& sm)
{
   Eigen::Matrix<double,3,3> downQuarksDRbar = ZEROMATRIX(3,3);
   downQuarksDRbar.diagonal() = sm.get_MFd();

   return downQuarksDRbar;
}

Eigen::Matrix<double,3,3> calculate_MFe_DRbar_tree_level(const Standard_model& sm)
{
   Eigen::Matrix<double,3,3> downLeptonsDRbar = ZEROMATRIX(3,3);
   downLeptonsDRbar.diagonal() = sm.get_MFe();

   return downLeptonsDRbar;
}

Eigen::Matrix<double,3,3> calculate_MFu_DRbar(const Standard_model& sm, const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> upQuarksDRbar = ZEROMATRIX(3,3);

@setRunningUpQuarkMasses@

   return upQuarksDRbar;
}

Eigen::Matrix<double,3,3> calculate_MFd_DRbar(const Standard_model& sm, const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> downQuarksDRbar = ZEROMATRIX(3,3);

@setRunningDownQuarkMasses@

   return downQuarksDRbar;
}

Eigen::Matrix<double,3,3> calculate_MFe_DRbar(const Standard_model& sm, const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> downLeptonsDRbar = ZEROMATRIX(3,3);

@setRunningDownLeptonMasses@

   return downLeptonsDRbar;
}

double calculate_MW_pole(const Standard_model& sm, const Standard_model& sm_0l)
{
   const double mw = sm.get_MVWp();
   const double p = sm_0l.get_MVWp();
   const double self_energy = Re(sm_0l.self_energy_VWp(p));
   const double M_loop = Sqr(mw) - self_energy;

   return SignedAbsSqrt(M_loop);
}

double calculate_MW_pole(const @ModelName@_mass_eigenstates& model, const @ModelName@_mass_eigenstates& model_0l)
{
   const double mw = model.get_M@VectorW(0)@;
   const double p = model_0l.get_M@VectorW(0)@;
   const double self_energy = Re(model_0l.self_energy_@VectorW@(p));
   const double M_loop = Sqr(mw) - self_energy;

   return SignedAbsSqrt(M_loop);
}

double calculate_MZ_pole(const Standard_model& sm, const Standard_model& sm_0l)
{
   const double mz = sm.get_MVZ();
   const double p = sm_0l.get_MVZ();
   const double self_energy = Re(sm_0l.self_energy_VZ(p));
   const double M_loop = Sqr(mz) - self_energy;

   return SignedAbsSqrt(M_loop);
}

double calculate_MZ_pole(const @ModelName@_mass_eigenstates& model, const @ModelName@_mass_eigenstates& model_0l)
{
   const double mz = model.get_M@VectorZ(0)@;
   const double p = model_0l.get_M@VectorZ(0)@;
   const double self_energy = Re(model_0l.self_energy_@VectorZ@(p));
   const double M_loop = Sqr(mz) - self_energy;

   return SignedAbsSqrt(M_loop);
}

double calculate_MW_DRbar(const Standard_model& sm, const Standard_model& sm_0l, @ModelName@_mass_eigenstates& model, const @ModelName@_mass_eigenstates& model_0l)
{
   const double MW_sm = calculate_MW_pole(sm, sm_0l);
   const double MW_bsm = calculate_MW_pole(model, model_0l);
   const double mw2 = Sqr(MW_sm) - Sqr(MW_bsm) + Sqr(model.get_M@VectorW(0)@);

   if (mw2 < 0.)
      model.get_problems().flag_running_tachyon(@ModelName@_info::@VectorW@);
   else
      model.get_problems().unflag_running_tachyon(@ModelName@_info::@VectorW@);

   return AbsSqrt(mw2);
}

double calculate_MZ_DRbar(const Standard_model& sm, const Standard_model& sm_0l, @ModelName@_mass_eigenstates& model, const @ModelName@_mass_eigenstates& model_0l)
{
   const double MZ_sm = calculate_MZ_pole(sm, sm_0l);
   const double MZ_bsm = calculate_MZ_pole(model, model_0l);
   const double mz2 = Sqr(MZ_sm) - Sqr(MZ_bsm) + Sqr(model.get_M@VectorZ(0)@);

   if (mz2 < 0.)
      model.get_problems().flag_running_tachyon(@ModelName@_info::@VectorZ@);
   else
      model.get_problems().unflag_running_tachyon(@ModelName@_info::@VectorZ@);

   return AbsSqrt(mz2);
}

/**
 * Calculates the gauge and Yukawa couplings and the SM-like VEV in
 * the @ModelName@ at the current loop level from the known Standard
 * Model couplings and the SM vev.
 */
void match_low_to_high_scale_model_impl(
   @ModelName@_mass_eigenstates& model, const @ModelName@_mass_eigenstates& model_0l, Standard_model& sm, unsigned idx)
{
   model.calculate_DRbar_masses();
   model.solve_ewsb();

   sm.calculate_DRbar_masses();
   sm.solve_ewsb();

   const double alpha_em = Sqr(sm.get_g1() * sm.get_g2() * standard_model_info::normalization_g1 * standard_model_info::normalization_g2)
            /(4. * Pi * (Sqr(sm.get_g1()*standard_model_info::normalization_g1) + Sqr(sm.get_g2()*standard_model_info::normalization_g2)));
   const double alpha_s  = Sqr(sm.get_g3() * standard_model_info::normalization_g3)/(4. * Pi);
   const double delta_alpha_em = calculate_delta_alpha_em(alpha_em, model_0l);
   const double delta_alpha_s = calculate_delta_alpha_s(alpha_s, model_0l);

   // running @ModelName@ W, Z masses (via 1L matching)
   const auto sm_0l = calculate_SM_tree_level(sm, model_0l, idx);
   const double mW2_1L = Sqr(calculate_MW_DRbar(sm, sm_0l, model, model_0l));
   const double mZ2_1L = Sqr(calculate_MZ_DRbar(sm, sm_0l, model, model_0l));

   // running @ModelName@ quark and lepton masses (via nL matching)
   const Eigen::Matrix<double, 3, 3> upQuarksDRbar    = calculate_MFu_DRbar_tree_level(sm);
   const Eigen::Matrix<double, 3, 3> downQuarksDRbar  = calculate_MFd_DRbar_tree_level(sm);
   const Eigen::Matrix<double, 3, 3> downLeptonsDRbar = calculate_MFe_DRbar_tree_level(sm);

   // running @ModelName@ gauge couplings (via 1L matching)
   const double g1_1L = AbsSqrt(4. * Pi * alpha_em * (1. + delta_alpha_em) * mZ2_1L / mW2_1L) / @ModelName@_info::normalization_@hyperchargeCoupling@;
   const double g2_1L = AbsSqrt(4. * Pi * alpha_em * (1. + delta_alpha_em) / (1. - mW2_1L/mZ2_1L)) / @ModelName@_info::normalization_@leftCoupling@;
   const double g3_1L = AbsSqrt(4. * Pi * alpha_s * (1. + delta_alpha_s)) / @ModelName@_info::normalization_@strongCoupling@;
   const double g3_0L = AbsSqrt(4. * Pi * alpha_s) / @ModelName@_info::normalization_@strongCoupling@;

   model.set_@hyperchargeCoupling@(g1_1L);
   model.set_@leftCoupling@(g2_1L);
   model.set_@strongCoupling@(g3_0L);

   {
      auto MODEL = &model;
      const double VEV = 2. * AbsSqrt(mZ2_1L/(Sqr(g1_1L*@ModelName@_info::normalization_@hyperchargeCoupling@) + Sqr(g2_1L*@ModelName@_info::normalization_@leftCoupling@)));

@applyUserMatching@
   }

#ifdef MODELPARAMETER
#undef MODELPARAMETER
#endif
#define MODELPARAMETER(p) model_0l.get_##p()
@setYukawas@
#ifdef MODELPARAMETER
#undef MODELPARAMETER
#endif
#define MODELPARAMETER(p) model.get_##p()
}

} // anonymous namespace

/**
 * Calculates \f$\lambda(Q)\f$ at the tree level from the lightest
 * CP-even Higgs boson mass of the @ModelName@.
 *
 * @param sm Standard Model parameters
 * @param model @ModelName@ parameters
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 */
void match_high_to_low_scale_model_tree_level(
   Standard_model& sm, @ModelName@_mass_eigenstates& model, unsigned idx)
{
   model.calculate_DRbar_masses();
   sm.set_Lambdax(Sqr(model.get_M@HiggsBoson(idx)@/sm.get_v()));
   sm.calculate_DRbar_masses();
}

/**
 * Calculates the gauge and Yukawa couplings and the SM-like VEV in
 * the @ModelName@ at the tree level from the known Standard Model
 * couplings and the SM vev.
 */
void match_low_to_high_scale_model_tree_level(
   @ModelName@_mass_eigenstates& model, Standard_model& sm)
{
   sm.calculate_DRbar_masses();
   model.set_@hyperchargeCoupling@(sm.get_g1()*standard_model_info::normalization_g1/@ModelName@_info::normalization_@hyperchargeCoupling@);
   model.set_@leftCoupling@(sm.get_g2()*standard_model_info::normalization_g2/@ModelName@_info::normalization_@leftCoupling@);
   model.set_@strongCoupling@(sm.get_g3()*standard_model_info::normalization_g3/@ModelName@_info::normalization_@strongCoupling@);

   {
      auto MODEL = &model;
      const double VEV = sm.get_v();

@applyUserMatching@
   }

   Eigen::Matrix<double, 3, 3> upQuarksDRbar    = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> downQuarksDRbar  = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> downLeptonsDRbar = ZEROMATRIX(3,3);

   upQuarksDRbar.diagonal()    = sm.get_MFu();
   downQuarksDRbar.diagonal()  = sm.get_MFd();
   downLeptonsDRbar.diagonal() = sm.get_MFe();

@setYukawas@

   model.calculate_DRbar_masses();
}

/**
 * Calculates the gauge and Yukawa couplings and the SM-like VEV in
 * the @ModelName@ at the 1-loop level from the known Standard Model
 * couplings and the SM vev.
 */
void match_low_to_high_scale_model(
   @ModelName@_mass_eigenstates& model, Standard_model& sm, unsigned idx, unsigned loop_order)
{
   if (loop_order == 0) {
      match_low_to_high_scale_model_tree_level(model, sm);
      return;
   }

   // tree-level @ModelName@ parameters
   const auto model_0l = calculate_@ModelName@_tree_level(model, sm);

   // temporarily set loop order to `loop_order'
   const auto los_sm = make_raii_set_loop_order(sm, loop_order);
   const auto los_model = make_raii_set_loop_order(model, loop_order);

   match_low_to_high_scale_model_impl(model, model_0l, sm, idx);

   model.get_physical().clear();
   sm.get_physical().clear();
}

/**
 * Calculates \f$\lambda(Q)\f$ at the 1-loop level from the lightest
 * CP-even Higgs boson mass of the @ModelName@ by requiring that the
 * 1-loop Higgs pole masses are equal in both models.
 *
 * @param sm Standard Model
 * @param model @ModelName@ parameters
 * @param loop_order downwards matching loop order
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 */
void match_high_to_low_scale_model(
   Standard_model& sm, @ModelName@_mass_eigenstates& model, unsigned loop_order, unsigned idx)
{
   if (loop_order == 0) {
      match_high_to_low_scale_model_tree_level(sm, model, idx);
      return;
   }

   // tree-level @ModelName@ parameters
   const auto model_0l = calculate_@ModelName@_tree_level(model, sm);

   // temporarily set loop order to `loop_order'
   const auto los_sm = make_raii_set_loop_order(sm, loop_order);
   const auto los_model = make_raii_set_loop_order(model, loop_order);

   match_high_to_low_scale_model_impl(sm, model, model_0l, idx);

   model.get_physical().clear();
   sm.get_physical().clear();
}

} // namespace @ModelName@_standard_model_matching
} // namespace flexiblesusy
