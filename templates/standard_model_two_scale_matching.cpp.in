// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_standard_model_two_scale_matching.hpp"
#include "@ModelName@_standard_model_matching.hpp"
#include "@ModelName@_two_scale_model.hpp"
#include "standard_model_two_scale_model.hpp"
#include "error.hpp"
#include "two_scale_constraint.hpp"

namespace flexiblesusy {

#define CLASSNAME @ModelName@_standard_model_matching_up<Two_scale>

CLASSNAME::@ModelName@_standard_model_matching_up()
   : model(0), eft(0), constraint(0), scale(0.)
   , loop_order(0)
   , higgs_idx(0)
{}

CLASSNAME::@ModelName@_standard_model_matching_up(
   standard_model::StandardModel<Two_scale>* low_,
   @ModelName@<Two_scale>* high_,
   Constraint<Two_scale>* constraint_,
   unsigned loop_order_,
   unsigned higgs_idx_)
   : model(high_)
   , eft(low_)
   , constraint(constraint_)
   , scale(0.)
   , higgs_idx(higgs_idx_)
{
   set_loop_order(loop_order_);
}

CLASSNAME::~@ModelName@_standard_model_matching_up()
{}

double CLASSNAME::get_scale() const
{
   if (scale != 0.)
      return scale;

   if (!constraint)
      throw SetupError("Constraint pointer in matching class is NULL!");

   return constraint->get_scale();
}

void CLASSNAME::set_models(Two_scale_model* low, Two_scale_model* high)
{
   eft = cast_model<standard_model::StandardModel<Two_scale>*>(low);
   model = cast_model<@ModelName@<Two_scale>*>(high);
}

void CLASSNAME::match()
{
   if (!model || !eft)
      throw SetupError("Model pointer in matching class is NULL!");
   if (!constraint)
      throw SetupError("Constraint pointer in matching class is NULL!");

   eft->run_to(get_scale());
   model->run_to(get_scale());

   if (model->get_thresholds() && loop_order)
      @ModelName@_standard_model_matching::match_low_to_high_scale_model(*model, *eft, loop_order);
   else
      @ModelName@_standard_model_matching::match_low_to_high_scale_model_tree_level(*model, *eft);
}

void CLASSNAME::match_tree_level()
{
   if (!model || !eft)
      throw SetupError("Model pointer in matching class is NULL!");
   if (!constraint)
      throw SetupError("Constraint pointer in matching class is NULL!");

   eft->run_to(get_scale());
   model->run_to(get_scale());

   @ModelName@_standard_model_matching::match_low_to_high_scale_model_tree_level(*model, *eft);
}

unsigned CLASSNAME::get_higgs_index() const
{
   return higgs_idx;
}

unsigned CLASSNAME::get_loop_order() const
{
   return loop_order;
}

void CLASSNAME::set_higgs_index(unsigned idx)
{
   higgs_idx = idx;
}

void CLASSNAME::set_loop_order(unsigned loop_order_)
{
   loop_order = loop_order_;
}

void CLASSNAME::set_constraint(Constraint<Two_scale>* constraint_)
{
   constraint = constraint_;
}

void CLASSNAME::set_scale(double scale_)
{
   scale = scale_;
}

#ifdef CLASSNAME
#undef CLASSNAME
#endif

#define CLASSNAME @ModelName@_standard_model_matching_down<Two_scale>

CLASSNAME::@ModelName@_standard_model_matching_down()
   : model(0), eft(0), constraint(0), scale(0.)
   , loop_order(0)
   , higgs_idx(0)
{}

CLASSNAME::@ModelName@_standard_model_matching_down(
   standard_model::StandardModel<Two_scale>* low_,
   @ModelName@<Two_scale>* high_,
   Constraint<Two_scale>* constraint_,
   unsigned loop_order_,
   unsigned higgs_idx_)
   : model(high_)
   , eft(low_)
   , constraint(constraint_)
   , scale(0.)
   , higgs_idx(higgs_idx_)
{
   set_loop_order(loop_order_);
}

CLASSNAME::~@ModelName@_standard_model_matching_down()
{}

double CLASSNAME::get_scale() const
{
   if (scale != 0.)
      return scale;

   if (!constraint)
      throw SetupError("Constraint pointer in matching class is NULL!");

   return constraint->get_scale();
}

void CLASSNAME::set_models(Two_scale_model* high, Two_scale_model* low)
{
   eft = cast_model<standard_model::StandardModel<Two_scale>*>(low);
   model = cast_model<@ModelName@<Two_scale>*>(high);
}

void CLASSNAME::match()
{
   if (!model || !eft)
      throw SetupError("Model pointer in matching class is NULL!");
   if (!constraint)
      throw SetupError("Constraint pointer in matching class is NULL!");

   eft->run_to(get_scale());
   model->run_to(get_scale());

   if (model->get_thresholds() && loop_order)
      @ModelName@_standard_model_matching::match_high_to_low_scale_model(*eft, *model, loop_order, higgs_idx);
   else
      @ModelName@_standard_model_matching::match_high_to_low_scale_model_tree_level(*eft, *model, higgs_idx);
}

void CLASSNAME::match_tree_level()
{
   if (!model || !eft)
      throw SetupError("Model pointer in matching class is NULL!");
   if (!constraint)
      throw SetupError("Constraint pointer in matching class is NULL!");

   eft->run_to(get_scale());
   model->run_to(get_scale());

   @ModelName@_standard_model_matching::match_high_to_low_scale_model_tree_level(*eft, *model, higgs_idx);
}

unsigned CLASSNAME::get_higgs_index() const
{
   return higgs_idx;
}

unsigned CLASSNAME::get_loop_order() const
{
   return loop_order;
}

void CLASSNAME::set_higgs_index(unsigned idx)
{
   higgs_idx = idx;
}

void CLASSNAME::set_loop_order(unsigned loop_order_)
{
   if (loop_order_ > 1) {
      WARNING("Matching loop order " << loop_order_
              << " for downwards matching currently not"
              " supported!  I'm using 1-loop matching.");
      loop_order_ = 1;
   }

   loop_order = loop_order_;
}

void CLASSNAME::set_constraint(Constraint<Two_scale>* constraint_)
{
   constraint = constraint_;
}

void CLASSNAME::set_scale(double scale_)
{
   scale = scale_;
}

} // namespace flexiblesusy
